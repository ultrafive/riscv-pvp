_: &default
  head: |
    #undef EXTRA_INIT
    #define EXTRA_INIT                               \
      li a0, 0x400;                                  \
      la a2, test_vlexff_data;                       \
      srli a3, a2, 2;                                \
      slli a3, a3, 2;                                \
      addi a3, a3, 0x500;                            \
    11:sb a0, (a3);                                  \
      addi a3, a3, -1;                               \
      addi a0, a0, -1;                               \
      bne a3, a2, 11b;                               \
      /* Set up a PMP to permit all accesses */      \
      la t0, test_vlexff_data;                       \
      addi t0, t0, 0x500;                            \
      srli t0, t0, 2;                                \
      csrw pmpaddr0, t0;                             \
      li t0, PMP_TOR | PMP_R | PMP_W | PMP_X;        \
      csrw pmpcfg0, t0;                                                    
    #include "exception.h"
  env: RVTEST_RV64UV
  templates:
    test_basic_without_mask: |
      test_{num}:
        li TESTNUM, {num};
        li a0, 0x400;
        li a1, 1;
        la a2, test_vlexff_data;
        mv a3, a2;
      12:sb a1, (a2)
        addi a1, a1, 1;
        addi a2, a2, 1;
        addi a0, a0, -1;
        bnez a0, 12b;

        li a0, {vlen};
        
        vsetvli t0, a0, e{ebits},m{lmul},tu,mu;
        vle{ebits}ff.v v8, (a3);
        
        la a2, test_{num}_data;
        vse{ebits}.v v8, (a2);

        .pushsection .data,1;
        .balign ({ebits}/8)
      test_{num}_data:
        .fill {vlen}, ({ebits}/8), 0;
        .popsection
        .pushsection .data, 1;
        .balign ({ebits}/8)
      test_vlexff_data:
        .fill ({vlen}), ({ebits} / 8), 0;
        .popsection
    test_exception_misaligned_base: |
      test_{num}:
        li t0, 4;
        la t1, _expected_cause;
        sw t0, 0(t1);
        la t0, test_{num}_end;
        la t1, _restore_addr;
        sd t0, 0(t1);
        li TESTNUM, {num};
        li a0, {vlen};
        vsetvli t0, a0, e{ebits},m1,tu,mu;
        la a1, {rs1_data};
        addi a1, a1, {offset};
        vle{ebits}ff.v v1, (a1);
        j fail;
        .pushsection .data, 1;
        .balign ({ebits}/8)
      test_vlexff_data:
        .fill ({vlen}), ({ebits} / 8), 0;
        .popsection
      test_{num}_end:
    test_exception_Fault_First: |
      test_{num}:
        li t0, 5;
        la t1, _expected_cause;
        sw t0, 0(t1);
        la t0, test_{num}_end;
        la t1, _restore_addr;
        sd t0, 0(t1);
        li TESTNUM, {num};
        li a0, {vlen};
        la a1, test_vlexff_data;
        addi a1, a1, 0x500;
        addi a1, a1, 0x400;
        vsetvli t0, a0, e{ebits},m{lmul},tu,mu;
        vle{ebits}ff.v v8, (a1);
        j fail;
        .pushsection .data, 1;
        .balign ({ebits}/8)
      test_vlexff_data:
        .fill ({vlen}), ({ebits} / 8), 0;
        .popsection
      test_{num}_end:
    test_exception_Fault_Not_First: |  
      test_{num}:
        li t0, 4;
        la t1, _expected_cause;
        sw t0, 0(t1);
        la t0, test_{num}_end;
        la t1, _restore_addr;
        sd t0, 0(t1);

        li TESTNUM, {num};

        li a1, {vlen};
        la a5, test_vlexff_data;
        li a6, 0xfffffffC;
        and a5, a5, a6;
        addi a5, a5, 0x500-{nvl}*{ebits}/8;
        vsetvli t0, a1, e{ebits},m{lmul},tu,mu
        vle{ebits}ff.v v16, (a5);
        csrr a2, vl;
        li a3, {nvl};
        bne a2, a3, fail;
        
        vsetvli t0, a2, e{ebits},m{lmul},tu,mu
        la a4, test_{num}_data;
        vse{ebits}.v v16, (a4);

        .pushsection .data, 1;
        .balign ({ebits}/8)
      test_{num}_data:
        .fill ({vlen}), ({ebits} / 8), 0;
        .popsection
        .pushsection .data, 1;
        .balign ({ebits}/8)
      test_vlexff_data:
        .fill ({vlen}), ({ebits} / 8), 0;
        .popsection
      test_{num}_end:


vle8ff_v:
  <<: *default
  cases:
    test_basic_without_mask @ vlen, lmul @ ebits=8:
      - "[   1, 1]"
      - "[  10, 1]"
      - "[ 128, 1]"      
      - "[ 129, 2]"      
      - "[ 255, 2]"
      - "[ 256, 2]"
      - "[ 512, 4]"
      - "[ 513, 8]"
      - "[1023, 8]"      
      - "[1024, 8]"      
    test_exception_Fault_First @ vlen, lmul @ ebits=8:
      - "[   1, 1]"
      - "[  10, 1]"
      - "[ 128, 1]"        
    test_exception_Fault_Not_First @ vlen, lmul, nvl @ ebits=8:
      - "[   1, 1,    1]"
      - "[  10, 1,    9]"
      - "[  10, 1,   10]"
      - "[ 128, 1,   64]" 
      - "[ 128, 1,  127]" 
      - "[ 128, 1,  128]" 
      - "[ 129, 2,  128]" 
      - "[ 256, 2,   64]" 
      - "[ 256, 2,  128]" 
      - "[ 256, 2,  255]" 
      - "[ 257, 4,  256]" 
      - "[ 512, 4,   64]" 
      - "[ 512, 4,  256]" 
      - "[ 512, 4,  511]" 
      - "[ 513, 8,  512]" 
      - "[1024, 8,   64]"   
      - "[1024, 8,  128]"   
      - "[1024, 8,  511]"   
      - "[1024, 8, 1023]"   
  
  check:
    test_basic_without_mask: np.array_equal(result, golden)
    test_exception_Fault_Not_First_PMP: np.array_equal(result, golden)

vle16ff_v:
  <<: *default
  cases:
    test_basic_without_mask @ vlen, lmul @ ebits=16:
      - "[   1, 1]"
      - "[  10, 1]"
      - "[  64, 1]"
      - "[  65, 2]"
      - "[ 128, 2]"      
      - "[ 129, 4]"      
      - "[ 255, 4]"
      - "[ 256, 4]"
      - "[ 257, 8]"
      - "[ 512, 8]"    
    test_exception_Fault_First @ vlen, lmul @ ebits=16:
      - "[   1, 1]"
      - "[  10, 1]"
    test_exception_Fault_Not_First @ vlen, lmul, nvl @ ebits=16:
      - "[   1, 1,    1]"
      - "[  10, 1,    9]"
      - "[  10, 1,   10]"
      - "[  64, 1,   32]"   
      - "[  64, 1,   63]"   
      - "[  64, 1,   64]"   
      - "[  65, 2,   64]"
      - "[ 128, 2,   64]" 
      - "[ 128, 2,  127]" 
      - "[ 128, 2,  128]" 
      - "[ 129, 4,  128]" 
      - "[ 256, 4,   64]" 
      - "[ 256, 4,  128]" 
      - "[ 256, 4,  255]" 
      - "[ 257, 8,  256]" 
      - "[ 512, 8,   64]" 
      - "[ 512, 8,  256]" 
      - "[ 512, 8,  511]" 
  
  check:
    test_basic_without_mask: np.array_equal(result, golden)
    test_exception_Fault_Not_First_PMP: np.array_equal(result, golden)

vle32ff_v:
  <<: *default
  cases:
    test_basic_without_mask @ vlen, lmul @ ebits=32:
      - "[   1, 1]"
      - "[  10, 1]"
      - "[  32, 1]"
      - "[  33, 2]"
      - "[  64, 2]"
      - "[  65, 4]"
      - "[ 128, 4]"      
      - "[ 129, 8]"      
      - "[ 255, 8]"
      - "[ 256, 8]"
    test_exception_Fault_First @ vlen, lmul @ ebits=32:
      - "[   1, 1]"
      - "[  10, 1]"
    test_exception_Fault_Not_First @ vlen, lmul, nvl @ ebits=32:
      - "[   1, 1,    1]"
      - "[  10, 1,    9]"
      - "[  10, 1,   10]"
      - "[  32, 1,   10]" 
      - "[  32, 1,   31]" 
      - "[  32, 1,   32]" 
      - "[  33, 2,   32]" 
      - "[  64, 2,   32]"   
      - "[  64, 2,   63]"   
      - "[  64, 2,   64]"   
      - "[  65, 4,   64]"
      - "[ 128, 4,   64]" 
      - "[ 128, 4,  127]" 
      - "[ 128, 4,  128]" 
      - "[ 129, 8,  128]" 
      - "[ 256, 8,   64]" 
      - "[ 256, 8,  128]" 
      - "[ 256, 8,  255]" 
  
  check:
    test_basic_without_mask: np.array_equal(result, golden)
    test_exception_Fault_Not_First_PMP: np.array_equal(result, golden)

vle64ff_v:
  <<: *default
  cases:
    test_basic_without_mask @ vlen, lmul @ ebits=64:
      - "[   1, 1]"
      - "[  10, 1]"
      - "[  16, 1]"      
      - "[  17, 2]"
      - "[  32, 2]"
      - "[  33, 4]"
      - "[  64, 4]"
      - "[  65, 8]"
      - "[ 128, 8]"      
    test_exception_Fault_First @ vlen, lmul @ ebits=64:
      - "[   1, 1]"
      - "[  10, 1]"
    test_exception_Fault_Not_First @ vlen, lmul, nvl @ ebits=64:
      - "[   1, 1,    1]"
      - "[  10, 1,    9]"
      - "[  10, 1,   10]"
      - "[  16, 1,    1]" 
      - "[  16, 1,   15]" 
      - "[  16, 1,   16]" 
      - "[  17, 2,   16]" 
      - "[  32, 2,   10]" 
      - "[  32, 2,   31]" 
      - "[  32, 2,   32]" 
      - "[  33, 4,   32]" 
      - "[  64, 4,   32]"   
      - "[  64, 4,   63]"   
      - "[  64, 4,   64]"   
      - "[  65, 8,   64]"
      - "[ 128, 8,   64]" 
      - "[ 128, 8,  127]" 
      - "[ 128, 8,  128]" 
  
  check:
    test_basic_without_mask: np.array_equal(result, golden)
    test_exception_Fault_Not_First_PMP: np.array_equal(result, golden)



