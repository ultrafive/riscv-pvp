{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview RISC-V PVP is a modular and parameterized RISC-V Processor Verification Platform. It currently supports the following features: Supported RISC-V ISA: V Extension, 1.0 YAML based hand-written sequence templates numpy based golden data for vector ISA Easy to support new targets with new or custom ISAs End-to-end RTL&ISS co-simulation flow Motivation Open source RISC-V processor verification solutions such as riscv-tests, riscv-arch-test have provided good sanity verifications for RISCV basic ISAs, but new extensions(for example, Vector, Bitmanip) support is missing. Our motivation is build a high quality open source verification platform to support more extensions easily to improve the verification quality of RISC-V processors. Issues Please file an issue under this repository for any bug report / integration issue / feature request. We are looking forward to knowing your experience of using this flow and how we can make it better together. License MIT License Copyright \u00a9 2020-2021 UltraFive Team Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Overview"},{"location":"#overview","text":"RISC-V PVP is a modular and parameterized RISC-V Processor Verification Platform. It currently supports the following features: Supported RISC-V ISA: V Extension, 1.0 YAML based hand-written sequence templates numpy based golden data for vector ISA Easy to support new targets with new or custom ISAs End-to-end RTL&ISS co-simulation flow","title":"Overview"},{"location":"#motivation","text":"Open source RISC-V processor verification solutions such as riscv-tests, riscv-arch-test have provided good sanity verifications for RISCV basic ISAs, but new extensions(for example, Vector, Bitmanip) support is missing. Our motivation is build a high quality open source verification platform to support more extensions easily to improve the verification quality of RISC-V processors.","title":"Motivation"},{"location":"#issues","text":"Please file an issue under this repository for any bug report / integration issue / feature request. We are looking forward to knowing your experience of using this flow and how we can make it better together.","title":"Issues"},{"location":"#license","text":"MIT License Copyright \u00a9 2020-2021 UltraFive Team Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"developing/","text":"Developing Guide Developing riscv-pvp riscv-pvp provide a python package, we should use --editable option while pip install to allow developing. pip install --editable . Debugging with VSCode The above configuration is used for developers to debugging rvpvp self in VSCode. After python extension is installed, we could place this into .vscode/launch.json then launch debugging. { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"rvpvp gen\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/rvpvp/main.py\" , \"args\" : [ \"gen\" , ], \"cwd\" : \"${workspaceFolder}/targets/spike-rv64gcv\" , \"console\" : \"integratedTerminal\" }, { \"name\" : \"rvpvp run\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/rvpvp/main.py\" , \"args\" : [ \"run\" , ], \"cwd\" : \"${workspaceFolder}/targets/spike-rv64gcv\" , \"console\" : \"integratedTerminal\" } ] }","title":"Developing Guide"},{"location":"developing/#developing-guide","text":"","title":"Developing Guide"},{"location":"developing/#developing-riscv-pvp","text":"riscv-pvp provide a python package, we should use --editable option while pip install to allow developing. pip install --editable .","title":"Developing riscv-pvp"},{"location":"developing/#debugging-with-vscode","text":"The above configuration is used for developers to debugging rvpvp self in VSCode. After python extension is installed, we could place this into .vscode/launch.json then launch debugging. { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"rvpvp gen\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/rvpvp/main.py\" , \"args\" : [ \"gen\" , ], \"cwd\" : \"${workspaceFolder}/targets/spike-rv64gcv\" , \"console\" : \"integratedTerminal\" }, { \"name\" : \"rvpvp run\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/rvpvp/main.py\" , \"args\" : [ \"run\" , ], \"cwd\" : \"${workspaceFolder}/targets/spike-rv64gcv\" , \"console\" : \"integratedTerminal\" } ] }","title":"Debugging with VSCode"},{"location":"get-started/","text":"Getting Started Prerequisites export RISCV = ~/opt/riscv Toolchains For latest rvv-0.10/1.0 support, we use llvm as the default toolchain. We could build it from source and install to $RISCV. $ git clone https://github.com/ultrafive/llvm-project $ cd llvm-project $ git checkout uf-master $ mkdir -p build && cd build && cmake -DCMAKE_INSTALL_PREFIX = $RISCV \\ -DCMAKE_BUILD_TYPE = Release -DLLVM_OPTIMIZED_TABLEGEN = On \\ -DLLVM_ENABLE_PROJECTS = \"clang;compiler-rt;lld\" \\ -DLLVM_LINK_LLVM_DYLIB = On ../llvm $ make -j ` nproc ` && make install llvm's libc development is still in the planning phase. To support c compiling, we still need a external libc. Let\u2018s build riscv-gnu-toolchain from source and install to $RISCV. $ git clone https://github.com/riscv/riscv-gnu-toolchain $ cd riscv-gnu-toolchain $ git checkout rvv-0.9.x $ git submodule update --init --recursive $ mkdir -p build && cd build && ../configure --prefix = $RISCV $ make -j ` nproc ` Instruction Set Simulators The default Instruction Set Simulator (ISS) is spike. We are working in progress to support more ISSs. $ git clone https://github.com/riscv/riscv-tools $ cd riscv-tools $ git submodule update --init --recursive $ cd riscv-isa-sim && git checkout master && git pull && cd .. $ ./build-spike-only.sh RTL Simulators To use the co-simulation flow, you need to have an RTL simulator which supports RISC-V Vector Extension 0.10/1.0. The RTL simulator also need to use \"+signature=\" argument provide a way to dump the \"begin_signature\" section to a file, this machanism is also used by riscv-torture or other RISC-V co-simulation flows. We have verified with Synopsys VCS, verilator in chipyard framework. Please make sure the EDA tool environment is properly setup before running the co-simulation flow. Use RISCV-PVP Getting the source from github. git clone https://github.com/ultrafive/riscv-pvp.git git submodule update --init Install dependencies and run. cd riscv-pvp pip3 install -U pip # update pip version pip3 install -r requirements.txt # install dependencies (only once) pip3 install . # install riscv-pvp package and cli Generate and run verification with default spike ISS target: cd targets/spike-rv64gcv rvpvp gen rvpvp run -n ` nproc `","title":"Getting Started"},{"location":"get-started/#getting-started","text":"","title":"Getting Started"},{"location":"get-started/#prerequisites","text":"export RISCV = ~/opt/riscv","title":"Prerequisites"},{"location":"get-started/#toolchains","text":"For latest rvv-0.10/1.0 support, we use llvm as the default toolchain. We could build it from source and install to $RISCV. $ git clone https://github.com/ultrafive/llvm-project $ cd llvm-project $ git checkout uf-master $ mkdir -p build && cd build && cmake -DCMAKE_INSTALL_PREFIX = $RISCV \\ -DCMAKE_BUILD_TYPE = Release -DLLVM_OPTIMIZED_TABLEGEN = On \\ -DLLVM_ENABLE_PROJECTS = \"clang;compiler-rt;lld\" \\ -DLLVM_LINK_LLVM_DYLIB = On ../llvm $ make -j ` nproc ` && make install llvm's libc development is still in the planning phase. To support c compiling, we still need a external libc. Let\u2018s build riscv-gnu-toolchain from source and install to $RISCV. $ git clone https://github.com/riscv/riscv-gnu-toolchain $ cd riscv-gnu-toolchain $ git checkout rvv-0.9.x $ git submodule update --init --recursive $ mkdir -p build && cd build && ../configure --prefix = $RISCV $ make -j ` nproc `","title":"Toolchains"},{"location":"get-started/#instruction-set-simulators","text":"The default Instruction Set Simulator (ISS) is spike. We are working in progress to support more ISSs. $ git clone https://github.com/riscv/riscv-tools $ cd riscv-tools $ git submodule update --init --recursive $ cd riscv-isa-sim && git checkout master && git pull && cd .. $ ./build-spike-only.sh","title":"Instruction Set Simulators"},{"location":"get-started/#rtl-simulators","text":"To use the co-simulation flow, you need to have an RTL simulator which supports RISC-V Vector Extension 0.10/1.0. The RTL simulator also need to use \"+signature=\" argument provide a way to dump the \"begin_signature\" section to a file, this machanism is also used by riscv-torture or other RISC-V co-simulation flows. We have verified with Synopsys VCS, verilator in chipyard framework. Please make sure the EDA tool environment is properly setup before running the co-simulation flow.","title":"RTL Simulators"},{"location":"get-started/#use-riscv-pvp","text":"Getting the source from github. git clone https://github.com/ultrafive/riscv-pvp.git git submodule update --init Install dependencies and run. cd riscv-pvp pip3 install -U pip # update pip version pip3 install -r requirements.txt # install dependencies (only once) pip3 install . # install riscv-pvp package and cli Generate and run verification with default spike ISS target: cd targets/spike-rv64gcv rvpvp gen rvpvp run -n ` nproc `","title":"Use RISCV-PVP"},{"location":"new-target/","text":"Support New Targets Create a New Target We could use rvpvp cli tool to create a new target. $ rvpvp new new-target It will create template files in the new created directory. $ cd new-target $ tree . \u251c\u2500\u2500 isa \u2502 \u2514\u2500\u2500 custom \u2502 \u2514\u2500\u2500 insts.py \u251c\u2500\u2500 specs \u2502 \u2514\u2500\u2500 custom \u2502 \u2514\u2500\u2500 vmod_vv.spec.yml \u2514\u2500\u2500 target.yml target.yml : target configuration file. isa : directory to define new instruction model specs : directory to define new verification cases Please read sections below for more information. Target Configuration File The target configuration file is used to tell rvpvp how to generate, compile and run verifcation cases. The default file is defined as below, we could override variables for new targets. processor : xlen : 64 flen : 64 vlen : 1024 elen : 64 slen : 1024 compile : path : clang cc : f'{path} --target=riscv{xlen}-unknown-elf -mno-relax -fuse-ld=lld -march=rv{xlen}gv0p10zfh0p1 -menable-experimental-extensions' defines : f'-DXLEN={xlen} -DVLEN={vlen}' cflags : -g -static -mcmodel=medany -fvisibility=hidden -nostdlib -nostartfiles linkflags : '' spike : path : spike # gem5: # path: ~/work/gem5/gem5/build/RISCV/gem5.opt # config: ~/work/gem5/gem5/configs/example/fs.py Add New Instructions To support new instructions, we should create a new Inst python class in isa/ directory. The new class inherits from the Inst class and should override these members and methods: name : the instruction assembly name string golden() : return the inst running result, usually the dest operator value computed from the source operators. This is a simple add instruction example: # isa/rvi/add.py from rvpvp.isa.inst import Inst class Add ( Inst ): name = 'add' def golden ( self ): rd = self [ 'rs1' ] + self [ 'rs2' ] return rd To support risc-v vector instructions, our vector inst model will receive numpy's ndarray for vector operators. For example, a vadd.vv model without mask could be defined as below. # isa/rvv/vadd_vv.py from rvpvp.isa.inst import Inst class Vadd_vv ( Inst ): name = 'vadd.vv' # vadd.vv vd, vs2, vs1 def golden ( self ): vd = self [ 'vs2' ] + self [ 'vs1' ] return vd Add Verification Cases Verification cases should be added in the spec/ directory. The detailed syntax is defined in Verification Case Specification . Generate and Run The target verification cases could be generated once the target cases are ready. $ rvpvp gen And then, we could run the generated cases. $ rvpvp run -n 80 The ISS and RTL simulator co-simulation flow are shown below.","title":"Support New Targets"},{"location":"new-target/#support-new-targets","text":"","title":"Support New Targets"},{"location":"new-target/#create-a-new-target","text":"We could use rvpvp cli tool to create a new target. $ rvpvp new new-target It will create template files in the new created directory. $ cd new-target $ tree . \u251c\u2500\u2500 isa \u2502 \u2514\u2500\u2500 custom \u2502 \u2514\u2500\u2500 insts.py \u251c\u2500\u2500 specs \u2502 \u2514\u2500\u2500 custom \u2502 \u2514\u2500\u2500 vmod_vv.spec.yml \u2514\u2500\u2500 target.yml target.yml : target configuration file. isa : directory to define new instruction model specs : directory to define new verification cases Please read sections below for more information.","title":"Create a New Target"},{"location":"new-target/#target-configuration-file","text":"The target configuration file is used to tell rvpvp how to generate, compile and run verifcation cases. The default file is defined as below, we could override variables for new targets. processor : xlen : 64 flen : 64 vlen : 1024 elen : 64 slen : 1024 compile : path : clang cc : f'{path} --target=riscv{xlen}-unknown-elf -mno-relax -fuse-ld=lld -march=rv{xlen}gv0p10zfh0p1 -menable-experimental-extensions' defines : f'-DXLEN={xlen} -DVLEN={vlen}' cflags : -g -static -mcmodel=medany -fvisibility=hidden -nostdlib -nostartfiles linkflags : '' spike : path : spike # gem5: # path: ~/work/gem5/gem5/build/RISCV/gem5.opt # config: ~/work/gem5/gem5/configs/example/fs.py","title":"Target Configuration File"},{"location":"new-target/#add-new-instructions","text":"To support new instructions, we should create a new Inst python class in isa/ directory. The new class inherits from the Inst class and should override these members and methods: name : the instruction assembly name string golden() : return the inst running result, usually the dest operator value computed from the source operators. This is a simple add instruction example: # isa/rvi/add.py from rvpvp.isa.inst import Inst class Add ( Inst ): name = 'add' def golden ( self ): rd = self [ 'rs1' ] + self [ 'rs2' ] return rd To support risc-v vector instructions, our vector inst model will receive numpy's ndarray for vector operators. For example, a vadd.vv model without mask could be defined as below. # isa/rvv/vadd_vv.py from rvpvp.isa.inst import Inst class Vadd_vv ( Inst ): name = 'vadd.vv' # vadd.vv vd, vs2, vs1 def golden ( self ): vd = self [ 'vs2' ] + self [ 'vs1' ] return vd","title":"Add New Instructions"},{"location":"new-target/#add-verification-cases","text":"Verification cases should be added in the spec/ directory. The detailed syntax is defined in Verification Case Specification .","title":"Add Verification Cases"},{"location":"new-target/#generate-and-run","text":"The target verification cases could be generated once the target cases are ready. $ rvpvp gen And then, we could run the generated cases. $ rvpvp run -n 80 The ISS and RTL simulator co-simulation flow are shown below.","title":"Generate and Run"},{"location":"reference/cli/","text":"Command Line Reference The RISC-V PVP Command Line Interface is a unified tool to manage your co-verification flow. rvpvp RISC-V PVP tool to manage co-verification flow. Usage: rvpvp [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. gen Generate verification cases for current target. Usage: rvpvp gen [OPTIONS] Options: --config TEXT config yaml file -n, --nproc INTEGER generate elf files on n processes -l, --level [group|type|case] level of cases to compile into one elf file -s, --specs TEXT test case specs -c, --cases TEXT test case list string or file, for example: - vsub_vv,addi/test_imm_op/ - cases.list you can find more examples with option --collect --collect BOOLEAN just collect the test case to know what cases we can test --little BOOLEAN only run at most 4 test cases for each test type of each instruction -b, --basic BOOLEAN run basic tests of basic_cases test data in yml for regression. -r, --random BOOLEAN run random tests of random_cases test data in yml --seed INTEGER set random seed for random functions of each spec yaml --rtimes INTEGER set random cases generation times --retry BOOLEAN retry last failed cases -fi, --failing-info BOOLEAN print the failing info into the screen, rather than into the log/generator_report.log. -pi, --param-info BOOLEAN print params information into log/params.yaml of cases collected. --help Show this message and exit. new Create a new target for verification. Usage: rvpvp new [OPTIONS] DIR Options: --help Show this message and exit. run Run verification cases for current target. Usage: rvpvp run [OPTIONS] Options: --config TEXT config yaml file, default config/prod.yml -r, --retry BOOLEAN retry last failed cases -n, --nproc INTEGER runner process number for run cases, default 1 -c, --cases TEXT test case list string or file, for example: - vsub_vv,addi/test_imm_op/ - cases.list -fi, --failing-info BOOLEAN print the failing info into the screen, rather than in the log/runner_report.log. --lsf BOOLEAN run tests on with lsf clusters, if not set, depend on lsf:is_flag in the file set by --config -f, --fsdb BOOLEAN generate fsdb waveform file when running vcs simulator, if not set, depend on vcs:fsdb in the file set by --config -tlm, --tsiloadmem BOOLEAN Load binary through TSI instead of backdoor, if not set, depend on vcs:tsiloadmem in the file set by --config -vto, --vcstimeout INTEGER Number of cycles after which VCS stops, if not set, depend on vcs:vcstimeout in the file set by --config --help Show this message and exit.","title":"Command Line"},{"location":"reference/cli/#command-line-reference","text":"The RISC-V PVP Command Line Interface is a unified tool to manage your co-verification flow.","title":"Command Line Reference"},{"location":"reference/cli/#rvpvp","text":"RISC-V PVP tool to manage co-verification flow. Usage: rvpvp [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit.","title":"rvpvp"},{"location":"reference/cli/#gen","text":"Generate verification cases for current target. Usage: rvpvp gen [OPTIONS] Options: --config TEXT config yaml file -n, --nproc INTEGER generate elf files on n processes -l, --level [group|type|case] level of cases to compile into one elf file -s, --specs TEXT test case specs -c, --cases TEXT test case list string or file, for example: - vsub_vv,addi/test_imm_op/ - cases.list you can find more examples with option --collect --collect BOOLEAN just collect the test case to know what cases we can test --little BOOLEAN only run at most 4 test cases for each test type of each instruction -b, --basic BOOLEAN run basic tests of basic_cases test data in yml for regression. -r, --random BOOLEAN run random tests of random_cases test data in yml --seed INTEGER set random seed for random functions of each spec yaml --rtimes INTEGER set random cases generation times --retry BOOLEAN retry last failed cases -fi, --failing-info BOOLEAN print the failing info into the screen, rather than into the log/generator_report.log. -pi, --param-info BOOLEAN print params information into log/params.yaml of cases collected. --help Show this message and exit.","title":"gen"},{"location":"reference/cli/#new","text":"Create a new target for verification. Usage: rvpvp new [OPTIONS] DIR Options: --help Show this message and exit.","title":"new"},{"location":"reference/cli/#run","text":"Run verification cases for current target. Usage: rvpvp run [OPTIONS] Options: --config TEXT config yaml file, default config/prod.yml -r, --retry BOOLEAN retry last failed cases -n, --nproc INTEGER runner process number for run cases, default 1 -c, --cases TEXT test case list string or file, for example: - vsub_vv,addi/test_imm_op/ - cases.list -fi, --failing-info BOOLEAN print the failing info into the screen, rather than in the log/runner_report.log. --lsf BOOLEAN run tests on with lsf clusters, if not set, depend on lsf:is_flag in the file set by --config -f, --fsdb BOOLEAN generate fsdb waveform file when running vcs simulator, if not set, depend on vcs:fsdb in the file set by --config -tlm, --tsiloadmem BOOLEAN Load binary through TSI instead of backdoor, if not set, depend on vcs:tsiloadmem in the file set by --config -vto, --vcstimeout INTEGER Number of cycles after which VCS stops, if not set, depend on vcs:vcstimeout in the file set by --config --help Show this message and exit.","title":"run"},{"location":"reference/spec/","text":"Verification Case Specification This is a detailed reference guide to RISC-V PVP Verification Case Specification. The best way to get started with YAML Verification Case Specification is to read the customization guide. After that, to learn how to write your YAML cases for your needs, see below topics. YAML basics Verification Case Specification is written in YAML file format. To learn the basics of YAML, please see Learn YAML in Y Minutes . Structure A verification case Group is a group of one or more verification Cases . These Cases share same Environment , Headers , Templates , case Params and Check rules. This hierarchy is reflected in the structure of a YAML file like: Group 1 Environment Headers Templates Params Check Group 2 Environment Headers Templates Params Check For example, We could define two simple case groups for rvv instructions, vadd.vi and vsub.vi. vadd_vi : env : ... head : ... templates : ... cases : ... check : ... vsub_vi : env : ... head : ... templates : ... cases : ... check : ... Since vadd.vi and vsub.vi are both Vector Integer Arithmetic Instructions, and could use same Environment , Headers , Templates , case Params and Check rules. So we could use YAML's \"anchors\" feature to duplicate/inherit properties from a same base group. _ : &default env : ... head : ... templates : ... cases : ... check : ... vadd_vi : << : *default vsub_vi : << : *default The base group is named _ , the vadd_vi and vsub_vi groups will inherit all its properties, such as env, head, templates, cases, check. Group names start with _ will be ignored by parser, and not consider as a valid group. So, the two syntax above are equivalent. Environment We reuse riscv-test-env to define target environments, test virtual machine ( TVM ) is used to define only used features for tests. The following table shows the TVMs currently defined. TVM Macro TVM Name Description RVTEST_RV32U rv32ui RV32 user-level, integer only RVTEST_RV32UF rv32uf RV32 user-level, integer and floating-point RVTEST_RV32UV rv32uv RV32 user-level, integer, floating-point, and vector RVTEST_RV32S rv32si RV32 supervisor-level, integer only RVTEST_RV32M rv32mi RV32 machine-level, integer only RVTEST_RV64U rv64ui RV64 user-level, integer only RVTEST_RV64UF rv64uf RV64 user-level, integer and floating-point RVTEST_RV64UV rv64uv RV64 user-level, integer, floating-point, and vector RVTEST_RV64S rv64si RV64 supervisor-level, integer only RVTEST_RV64M rv64mi RV64 machine-level, integer only For example, we use RVTEST_RV64UV for all rvv cases. _ : &default env : RVTEST_RV64UV ... vadd_vi : << : *default vsub_vi : << : *default Headers Headers section is used for test case templates to include header files. The header files are placed in macros directory. For example, all rvv cases will include \"test_macros_v.h\". _ : &default env : RVTEST_RV64UV head : | #include \"test_macros_v.h\" ... vadd_vi : << : *default vsub_vi : << : *default Templates Templates section is used to place assembly code template for test cases. The key is the test case name, value is the code template string for this test case. Variables in templates are delimited by braces {} . Except for internal variables, other variables will be instantiated with the parameters defined in the Cases section. The following table shows the internal variables currently defined. Variable Description num test case index number name instruction name converted from group name, vadd_vi will convert into vadd.vi *_shape data will be generated by numpy's ndarray, this variable is the data shape. *_data data will be generated by numpy's ndarray, this variable is the data address. For example, the below template is a basic test case test_basic_without_mask for v*.vi . Except for internal variables, other variables such as vs2_data , imm , vl , sew , lmul should be defined in Cases section. _ : &default env : RVTEST_RV64UV head : | #include \"test_macros_v.h\" templates : test_basic_without_mask : | test_{num}: li TESTNUM, {num}; // set vtype and vl li a0, {vl}; vsetvli t0, a0, e{sew},m{lmul},ta,ma; // load input data into source vregs la a2, {vs2_data}; vle{sew}.v v16, (a2); // run tested instruction {name} v24, v16, {imm}; // store output data into result sections la a4, test_{num}_data; vse{sew}.v v24, (a4); // push a result sub-section into signature in data section .pushsection .data, 1; .balign ({sew}/8) test_{num}_data: .fill ({vl}), ({sew}/8), 0; .popsection test_basic_with_mask : | ... ... vadd_vi : << : *default vsub_vi : << : *default Cases Cases section defines test case parameters to instantiate the teamplate variables. There are three method to define parameters. Parameter Array The simplest method is define a parameter array. Continue with the above example, we will define vs2_data , imm , vl , sew , lmul parameters for test_basic_without_mask test case. Each array item is a parameter array written in python. _ : &default env : RVTEST_RV64UV head : | #include \"test_macros_v.h\" templates : test_basic_without_mask : | ... cases : test_basic_without_mask @ vs2, imm, vl, sew @ lmul = 1 : - '[np.array([4], dtype=np.int8), 4, 1, 8]' - '[np.array([-2], dtype=np.int16), 3, 1, 16]' - '[np.linspace(0, 1, 16, dtype=np.int32), 9, 16, 32]' - '[np.linspace(0, -1, -31, dtype=np.int32), 13, 31, 8]' - '[np.linspace(0, -15, 16, dtype=np.int32), 15, 32, 16]' Parameter Matrix We could define a parameter matrix to combine parameters. The parameter matrix is a YAML object with a single matrix key in it. The keys of the matrix object are variable names, and the values are also written in python. _ : &default env : RVTEST_RV64UV head : | #include \"test_macros_v.h\" templates : test_basic_without_mask : | ... cases : test_basic_without_mask : matrix : sew : [ 8 , 16 , 32 , 64 ] lmul : get_lmul_w(sew) vl : get_vl(lmul, sew, vlen) vs1 : np.linspace(-100, 100).astype(get_intdtype(sew)) imm : [ 1 , -1 , 100 ] Setup Script Pure python script to define parameters is also supported. A YAML object with a single setup key in it is used to define setup script. Int the python script, we should define and push all parameters into a params_yml array. _ : &default env : RVTEST_RV64UV head : | #include \"test_macros_v.h\" templates : test_basic_without_mask : | ... cases : test_basic_without_mask @ vs2, imm, vl, sew, lmul : setup : | params_yml = [] for sew in [8, 16, 32, 64]: for lmul in get_lmul_w(sew): for vl in get_vl(lmul, sew, vlen): vs2 = np.linspace(-100, 100).astype(get_intdtype(sew)) imm = [1, -1, 100] params_yml.append([vs2, imm, vl, sew, lmul]) Check Finally, we should define the check result rules in check section. RISC-V PVP will compile the parameters injected templates into target elf file, and run simulators to get result. Then, the result and golden will convert into numpy ndarray's. The check section is python code how to check result and golden , it will return true if the check pass, otherwise false. _ : &default env : RVTEST_RV64UV head : | #include \"test_macros_v.h\" templates : test_basic_without_mask : | ... cases : test_basic_without_mask : ... check : test_basic_without_mask : np.array_equal(result, golden)","title":"Cases"},{"location":"reference/spec/#verification-case-specification","text":"This is a detailed reference guide to RISC-V PVP Verification Case Specification. The best way to get started with YAML Verification Case Specification is to read the customization guide. After that, to learn how to write your YAML cases for your needs, see below topics.","title":"Verification Case Specification"},{"location":"reference/spec/#yaml-basics","text":"Verification Case Specification is written in YAML file format. To learn the basics of YAML, please see Learn YAML in Y Minutes .","title":"YAML basics"},{"location":"reference/spec/#structure","text":"A verification case Group is a group of one or more verification Cases . These Cases share same Environment , Headers , Templates , case Params and Check rules. This hierarchy is reflected in the structure of a YAML file like: Group 1 Environment Headers Templates Params Check Group 2 Environment Headers Templates Params Check For example, We could define two simple case groups for rvv instructions, vadd.vi and vsub.vi. vadd_vi : env : ... head : ... templates : ... cases : ... check : ... vsub_vi : env : ... head : ... templates : ... cases : ... check : ... Since vadd.vi and vsub.vi are both Vector Integer Arithmetic Instructions, and could use same Environment , Headers , Templates , case Params and Check rules. So we could use YAML's \"anchors\" feature to duplicate/inherit properties from a same base group. _ : &default env : ... head : ... templates : ... cases : ... check : ... vadd_vi : << : *default vsub_vi : << : *default The base group is named _ , the vadd_vi and vsub_vi groups will inherit all its properties, such as env, head, templates, cases, check. Group names start with _ will be ignored by parser, and not consider as a valid group. So, the two syntax above are equivalent.","title":"Structure"},{"location":"reference/spec/#environment","text":"We reuse riscv-test-env to define target environments, test virtual machine ( TVM ) is used to define only used features for tests. The following table shows the TVMs currently defined. TVM Macro TVM Name Description RVTEST_RV32U rv32ui RV32 user-level, integer only RVTEST_RV32UF rv32uf RV32 user-level, integer and floating-point RVTEST_RV32UV rv32uv RV32 user-level, integer, floating-point, and vector RVTEST_RV32S rv32si RV32 supervisor-level, integer only RVTEST_RV32M rv32mi RV32 machine-level, integer only RVTEST_RV64U rv64ui RV64 user-level, integer only RVTEST_RV64UF rv64uf RV64 user-level, integer and floating-point RVTEST_RV64UV rv64uv RV64 user-level, integer, floating-point, and vector RVTEST_RV64S rv64si RV64 supervisor-level, integer only RVTEST_RV64M rv64mi RV64 machine-level, integer only For example, we use RVTEST_RV64UV for all rvv cases. _ : &default env : RVTEST_RV64UV ... vadd_vi : << : *default vsub_vi : << : *default","title":"Environment"},{"location":"reference/spec/#headers","text":"Headers section is used for test case templates to include header files. The header files are placed in macros directory. For example, all rvv cases will include \"test_macros_v.h\". _ : &default env : RVTEST_RV64UV head : | #include \"test_macros_v.h\" ... vadd_vi : << : *default vsub_vi : << : *default","title":"Headers"},{"location":"reference/spec/#templates","text":"Templates section is used to place assembly code template for test cases. The key is the test case name, value is the code template string for this test case. Variables in templates are delimited by braces {} . Except for internal variables, other variables will be instantiated with the parameters defined in the Cases section. The following table shows the internal variables currently defined. Variable Description num test case index number name instruction name converted from group name, vadd_vi will convert into vadd.vi *_shape data will be generated by numpy's ndarray, this variable is the data shape. *_data data will be generated by numpy's ndarray, this variable is the data address. For example, the below template is a basic test case test_basic_without_mask for v*.vi . Except for internal variables, other variables such as vs2_data , imm , vl , sew , lmul should be defined in Cases section. _ : &default env : RVTEST_RV64UV head : | #include \"test_macros_v.h\" templates : test_basic_without_mask : | test_{num}: li TESTNUM, {num}; // set vtype and vl li a0, {vl}; vsetvli t0, a0, e{sew},m{lmul},ta,ma; // load input data into source vregs la a2, {vs2_data}; vle{sew}.v v16, (a2); // run tested instruction {name} v24, v16, {imm}; // store output data into result sections la a4, test_{num}_data; vse{sew}.v v24, (a4); // push a result sub-section into signature in data section .pushsection .data, 1; .balign ({sew}/8) test_{num}_data: .fill ({vl}), ({sew}/8), 0; .popsection test_basic_with_mask : | ... ... vadd_vi : << : *default vsub_vi : << : *default","title":"Templates"},{"location":"reference/spec/#cases","text":"Cases section defines test case parameters to instantiate the teamplate variables. There are three method to define parameters.","title":"Cases"},{"location":"reference/spec/#parameter-array","text":"The simplest method is define a parameter array. Continue with the above example, we will define vs2_data , imm , vl , sew , lmul parameters for test_basic_without_mask test case. Each array item is a parameter array written in python. _ : &default env : RVTEST_RV64UV head : | #include \"test_macros_v.h\" templates : test_basic_without_mask : | ... cases : test_basic_without_mask @ vs2, imm, vl, sew @ lmul = 1 : - '[np.array([4], dtype=np.int8), 4, 1, 8]' - '[np.array([-2], dtype=np.int16), 3, 1, 16]' - '[np.linspace(0, 1, 16, dtype=np.int32), 9, 16, 32]' - '[np.linspace(0, -1, -31, dtype=np.int32), 13, 31, 8]' - '[np.linspace(0, -15, 16, dtype=np.int32), 15, 32, 16]'","title":"Parameter Array"},{"location":"reference/spec/#parameter-matrix","text":"We could define a parameter matrix to combine parameters. The parameter matrix is a YAML object with a single matrix key in it. The keys of the matrix object are variable names, and the values are also written in python. _ : &default env : RVTEST_RV64UV head : | #include \"test_macros_v.h\" templates : test_basic_without_mask : | ... cases : test_basic_without_mask : matrix : sew : [ 8 , 16 , 32 , 64 ] lmul : get_lmul_w(sew) vl : get_vl(lmul, sew, vlen) vs1 : np.linspace(-100, 100).astype(get_intdtype(sew)) imm : [ 1 , -1 , 100 ]","title":"Parameter Matrix"},{"location":"reference/spec/#setup-script","text":"Pure python script to define parameters is also supported. A YAML object with a single setup key in it is used to define setup script. Int the python script, we should define and push all parameters into a params_yml array. _ : &default env : RVTEST_RV64UV head : | #include \"test_macros_v.h\" templates : test_basic_without_mask : | ... cases : test_basic_without_mask @ vs2, imm, vl, sew, lmul : setup : | params_yml = [] for sew in [8, 16, 32, 64]: for lmul in get_lmul_w(sew): for vl in get_vl(lmul, sew, vlen): vs2 = np.linspace(-100, 100).astype(get_intdtype(sew)) imm = [1, -1, 100] params_yml.append([vs2, imm, vl, sew, lmul])","title":"Setup Script"},{"location":"reference/spec/#check","text":"Finally, we should define the check result rules in check section. RISC-V PVP will compile the parameters injected templates into target elf file, and run simulators to get result. Then, the result and golden will convert into numpy ndarray's. The check section is python code how to check result and golden , it will return true if the check pass, otherwise false. _ : &default env : RVTEST_RV64UV head : | #include \"test_macros_v.h\" templates : test_basic_without_mask : | ... cases : test_basic_without_mask : ... check : test_basic_without_mask : np.array_equal(result, golden)","title":"Check"},{"location":"reference/functions/data/","text":"Generate data for test cases You can use functions and lists in this module to generate data for cases. scalar_float_list_special ( sew ) Function to generate a list special float numbers of which the data type is depended on sew. Parameters: Name Type Description Default sew int sew decides the element width and data type for special float numbers. 16 - float16 32 - float32 64 - float64 required Returns: Type Description list A list of 8 numpy ndarrays. When sew == 16, return the result of special_fp16(). When sew == 32, return the result of special_fp32(). When sew == 64, return the result of special_fp64(). Source code in rvpvp/utils/data.py def scalar_float_list_special ( sew ): '''Function to generate a list special float numbers of which the data type is depended on sew. Args: sew (int): sew decides the element width and data type for special float numbers. 16 - float16 32 - float32 64 - float64 Returns: list: A list of 8 numpy ndarrays. When sew == 16, return the result of special_fp16(). When sew == 32, return the result of special_fp32(). When sew == 64, return the result of special_fp64(). ''' if sew == 16 : return special_fp16 () if sew == 32 : return special_fp32 () if sew == 64 : return special_fp64 () scalar_float_random ( sew , vl ) Function to return a numpy ndarray of random float numbers. Parameters: Name Type Description Default sew int vsew register value, float number width. It can be 16, 32, 64 corresponding to float16, float32 and float64. required vl int vector length, the size of numpy ndarray. required Returns: Type Description numpy ndarray A numpy ndarray with random numbers in the full range of float data type. Its size is vl. Its dtype is float16, float32 or float64 corresponding to the input width, sew. Exceptions: Type Description ValueError If sew isn't equal to 16, 32, 64. Source code in rvpvp/utils/data.py def scalar_float_random ( sew , vl ): '''Function to return a numpy ndarray of random float numbers. Args: sew (int): vsew register value, float number width. It can be 16, 32, 64 corresponding to float16, float32 and float64. vl (int): vector length, the size of numpy ndarray. Returns: numpy ndarray: A numpy ndarray with random numbers in the full range of float data type. Its size is vl. Its dtype is float16, float32 or float64 corresponding to the input width, sew. Raises: ValueError: If sew isn't equal to 16, 32, 64. ''' if sew == 16 : num = np . random . randint ( 0 , 0x10000 , size = vl , dtype = np . uint16 ) num . dtype = np . float16 elif sew == 32 : num = np . random . randint ( 0 , 0x100000000 , size = vl , dtype = np . uint32 ) num . dtype = np . float32 elif sew == 64 : num = np . random . randint ( 0 , 1 << 64 , size = vl , dtype = np . uint64 ) num . dtype = np . float64 else : raise ValueError ( f ' { sew } is not a good option for sew.' ) return num scalar_int_random ( sew , vl ) Function to return a numpy ndarray of random int numbers. Parameters: Name Type Description Default sew int vsew register value, int number width. It can be 8, 16, 32, 64 corresponding to int8, int16, required vl int vector length, the size of numpy ndarray. required Returns: Type Description numpy ndarray A numpy ndarray with random numbers in the full range of int data type. Its size is vl. Its dtype is int8, int16, int32 or int64 corresponding to the input width, sew. Exceptions: Type Description ValueError If sew isn't equal to 8, 16, 32, 64. Source code in rvpvp/utils/data.py def scalar_int_random ( sew , vl ): '''Function to return a numpy ndarray of random int numbers. Args: sew (int): vsew register value, int number width. It can be 8, 16, 32, 64 corresponding to int8, int16, int32, int64. vl (int): vector length, the size of numpy ndarray. Returns: numpy ndarray: A numpy ndarray with random numbers in the full range of int data type. Its size is vl. Its dtype is int8, int16, int32 or int64 corresponding to the input width, sew. Raises: ValueError: If sew isn't equal to 8, 16, 32, 64. ''' if sew == 8 : num = np . random . randint ( 0 , 0x100 , size = vl , dtype = np . uint8 ) num . dtype = np . int8 elif sew == 16 : num = np . random . randint ( 0 , 0x10000 , size = vl , dtype = np . uint16 ) num . dtype = np . int16 elif sew == 32 : num = np . random . randint ( 0 , 0x100000000 , size = vl , dtype = np . uint32 ) num . dtype = np . int32 elif sew == 64 : num = np . random . randint ( 0 , 1 << 64 , size = vl , dtype = np . uint64 ) num . dtype = np . int64 else : raise ValueError ( f ' { sew } is not a good option for sew.' ) return num scalar_uint_random ( sew , vl ) Function to return a numpy ndarray of random uint numbers. Parameters: Name Type Description Default sew int vsew register value, int number width. It can be 8, 16, 32, 64 corresponding to uint8, uint16, required vl int vector length, the size of numpy ndarray. required Returns: Type Description numpy ndarray A numpy ndarray with random numbers in the full range of uint data type. Its size is vl. Its dtype is uint8, uint16, uint32 or uint64 corresponding to the input width, sew. Exceptions: Type Description ValueError If sew isn't equal to 8, 16, 32, 64. Source code in rvpvp/utils/data.py def scalar_uint_random ( sew , vl ): '''Function to return a numpy ndarray of random uint numbers. Args: sew (int): vsew register value, int number width. It can be 8, 16, 32, 64 corresponding to uint8, uint16, uint32, uint64. vl (int): vector length, the size of numpy ndarray. Returns: numpy ndarray: A numpy ndarray with random numbers in the full range of uint data type. Its size is vl. Its dtype is uint8, uint16, uint32 or uint64 corresponding to the input width, sew. Raises: ValueError: If sew isn't equal to 8, 16, 32, 64. ''' if sew == 8 : num = np . random . randint ( 0 , 0x100 , size = vl , dtype = np . uint8 ) elif sew == 16 : num = np . random . randint ( 0 , 0x10000 , size = vl , dtype = np . uint16 ) elif sew == 32 : num = np . random . randint ( 0 , 0x100000000 , size = vl , dtype = np . uint32 ) elif sew == 64 : num = np . random . randint ( 0 , 1 << 64 , size = vl , dtype = np . uint64 ) else : raise ValueError ( f ' { sew } is not a good option for sew.' ) return num vector_float_array_special ( sew ) Function to generate a special float numpy ndarray of which the data type is decided by sew. Parameters: Name Type Description Default sew int sew decides the element width and data type for special float numbers. 16 - float16 32 - float32 64 - float64 required Returns: Type Description numpy ndarray When sew == 16, return the result of special_v_fp16(). When sew == 32, return the result of special_v_fp32(). When sew == 64, return the result of special_v_fp64(). Source code in rvpvp/utils/data.py def vector_float_array_special ( sew ): '''Function to generate a special float numpy ndarray of which the data type is decided by sew. Args: sew (int): sew decides the element width and data type for special float numbers. 16 - float16 32 - float32 64 - float64 Returns: numpy ndarray: When sew == 16, return the result of special_v_fp16(). When sew == 32, return the result of special_v_fp32(). When sew == 64, return the result of special_v_fp64(). ''' if sew == 16 : return special_v_fp16 () if sew == 32 : return special_v_fp32 () if sew == 64 : return special_v_fp64 () vector_float_array_special_fp16_vv () Function to generate a list of 2 numpy ndarrays which include 32 special float16 numbers. Returns: Type Description list The list includes 2 numpy ndarrays. There are 32 special float16 numbers in every ndarray. The corresponding elements pairs in these ndarrays are different and comprehensive. So users can use these two ndarrays to test the results between two special float16 numbers. Source code in rvpvp/utils/data.py def vector_float_array_special_fp16_vv (): '''Function to generate a list of 2 numpy ndarrays which include 32 special float16 numbers. Returns: list: The list includes 2 numpy ndarrays. There are 32 special float16 numbers in every ndarray. The corresponding elements pairs in these ndarrays are different and comprehensive. So users can use these two ndarrays to test the results between two special float16 numbers. ''' # special float table -0 , inf , -inf , nan , 0.1 , 10 , 65500 , 6.104e-05, 6.e-08 fpt0 = np . array ([[ 0x0000 ] * 6 , [ 0x8000 , 0x7c00 , 0x7e00 , 0x7bff , 0x0400 , 0x0001 ]], dtype = np . int16 ) fpt1 = np . array ([[ 0x7c00 ] * 8 , [ 0x7c00 , 0xfc00 , 0x7e00 , 0x2e66 , 0x4900 , 0x7bff , 0x0400 , 0x0001 ]], dtype = np . int16 ) fpt2 = np . array ([[ 0x7e00 ] * 6 , [ 0x7e00 , 0x2e66 , 0x4900 , 0x7bff , 0x0400 , 0x0001 ]], dtype = np . int16 ) fpt3 = np . array ([[ 0x2e66 ] * 3 , [ 0x7bff , 0x0400 , 0x0001 ]], dtype = np . int16 ) fpt4 = np . array ([[ 0x4900 ] * 3 , [ 0x7bff , 0x0400 , 0x0001 ]], dtype = np . int16 ) fpt5 = np . array ([[ 0x7bff ] * 3 , [ 0x7bff , 0x0400 , 0x0001 ]], dtype = np . int16 ) fpt6 = np . array ([[ 0x0400 ] * 2 , [ 0x0400 , 0x0001 ]], dtype = np . int16 ) fpt7 = np . array ([[ 0x0001 ] * 1 , [ 0x0001 ]], dtype = np . int16 ) fpt_data = np . concatenate (( fpt0 , fpt1 , fpt2 , fpt3 , fpt4 , fpt5 , fpt6 , fpt7 ), axis = 1 ) fpt_data . dtype = np . float16 return [ fpt_data [ 0 ], fpt_data [ 1 ] ] vector_float_array_special_fp32_vv () Function to generate a list of 2 numpy ndarrays which include 32 special float32 numbers. Returns: Type Description list The list includes 2 numpy ndarrays. There are 32 special float32 numbers in every ndarray. The corresponding elements pairs in these ndarrays are different and comprehensive. So users can use these two ndarrays to test the results between two special float32 numbers. Source code in rvpvp/utils/data.py def vector_float_array_special_fp32_vv (): '''Function to generate a list of 2 numpy ndarrays which include 32 special float32 numbers. Returns: list: The list includes 2 numpy ndarrays. There are 32 special float32 numbers in every ndarray. The corresponding elements pairs in these ndarrays are different and comprehensive. So users can use these two ndarrays to test the results between two special float32 numbers. ''' # special float table -0 , inf , -inf , nan , 0.1 , 10 , 3.40282e+38, 1.1755e-38, 1e-45 fpt0 = np . array ([[ 0x00000000 ] * 6 , [ 0x80000000 , 0x7f800000 , 0x7fc00000 , 0x7f7fffff , 0x00800000 , 0x00000001 ]], dtype = np . int32 ) fpt1 = np . array ([[ 0x7f800000 ] * 8 , [ 0x7f800000 , 0xff800000 , 0x7fc00000 , 0x3dcccccd , 0x41200000 , 0x7f7fffff , 0x00800000 , 0x00000001 ]], dtype = np . int32 ) fpt2 = np . array ([[ 0x7fc00000 ] * 6 , [ 0x7fc00000 , 0x3dcccccd , 0x41200000 , 0x7f7fffff , 0x00800000 , 0x00000001 ]], dtype = np . int32 ) fpt3 = np . array ([[ 0x3dcccccd ] * 3 , [ 0x7f7fffff , 0x00800000 , 0x00000001 ]], dtype = np . int32 ) fpt4 = np . array ([[ 0x41200000 ] * 3 , [ 0x7f7fffff , 0x00800000 , 0x00000001 ]], dtype = np . int32 ) fpt5 = np . array ([[ 0x7f7fffff ] * 3 , [ 0x7f7fffff , 0x00800000 , 0x00000001 ]], dtype = np . int32 ) fpt6 = np . array ([[ 0x00800000 ] * 2 , [ 0x00800000 , 0x00000001 ]], dtype = np . int32 ) fpt7 = np . array ([[ 0x00000001 ] * 1 , [ 0x00000001 ]], dtype = np . int32 ) fpt_data = np . concatenate (( fpt0 , fpt1 , fpt2 , fpt3 , fpt4 , fpt5 , fpt6 , fpt7 ), axis = 1 ) fpt_data . dtype = np . float32 return [ fpt_data [ 0 ], fpt_data [ 1 ] ] vector_float_array_special_fp64_vv () Function to generate a list of 2 numpy ndarrays which include 32 special float64 numbers. Returns: Type Description list The list includes 2 numpy ndarrays. There are 32 special float64 numbers in every ndarray. The corresponding elements pairs in these ndarrays are different and comprehensive. So users can use these two ndarrays to test the results between two special float64 numbers. Source code in rvpvp/utils/data.py def vector_float_array_special_fp64_vv (): '''Function to generate a list of 2 numpy ndarrays which include 32 special float64 numbers. Returns: list: The list includes 2 numpy ndarrays. There are 32 special float64 numbers in every ndarray. The corresponding elements pairs in these ndarrays are different and comprehensive. So users can use these two ndarrays to test the results between two special float64 numbers. ''' # special float table -0 , inf , -inf , nan , 0.1 , 10 , 1.79769313e+308, 2.22507386e-308, 5.e-324 fpt0 = np . array ([[ 0x0000000000000000 ] * 6 , [ 0x8000000000000000 , 0x7ff0000000000000 , 0x7ff8000000000000 , 0x7fefffffffffffff , 0x0010000000000000 , 0x0000000000000001 ]], dtype = np . uint64 ) fpt1 = np . array ([[ 0x7ff0000000000000 ] * 8 , [ 0x7ff0000000000000 , 0xfff0000000000000 , 0x7ff8000000000000 , 0x3fb999999999999a , 0x4024000000000000 , 0x7fefffffffffffff , 0x0010000000000000 , 0x0000000000000001 ]], dtype = np . uint64 ) fpt2 = np . array ([[ 0x7ff8000000000000 ] * 6 , [ 0x7ff8000000000000 , 0x3fb999999999999a , 0x4024000000000000 , 0x7fefffffffffffff , 0x0010000000000000 , 0x0000000000000001 ]], dtype = np . uint64 ) fpt3 = np . array ([[ 0x3fb999999999999a ] * 3 , [ 0x7fefffffffffffff , 0x0010000000000000 , 0x0000000000000001 ]], dtype = np . uint64 ) fpt4 = np . array ([[ 0x4024000000000000 ] * 3 , [ 0x7fefffffffffffff , 0x0010000000000000 , 0x0000000000000001 ]], dtype = np . uint64 ) fpt5 = np . array ([[ 0x7fefffffffffffff ] * 3 , [ 0x7fefffffffffffff , 0x0010000000000000 , 0x0000000000000001 ]], dtype = np . uint64 ) fpt6 = np . array ([[ 0x0010000000000000 ] * 2 , [ 0x0010000000000000 , 0x0000000000000001 ]], dtype = np . uint64 ) fpt7 = np . array ([[ 0x0000000000000001 ] * 1 , [ 0x0000000000000001 ]], dtype = np . uint64 ) fpt_data = np . concatenate (( fpt0 , fpt1 , fpt2 , fpt3 , fpt4 , fpt5 , fpt6 , fpt7 ), axis = 1 ) fpt_data . dtype = np . float64 return [ fpt_data [ 0 ], fpt_data [ 1 ] ] vector_illegal_lmul ( sew ) Function to get illegal lmul with input sew. Parameters: Name Type Description Default sew int vsew register value, which can be 8, 16, 32, 64. required Returns: Type Description list illegal lmul with input sew, when sew == 8, return None. Source code in rvpvp/utils/data.py def vector_illegal_lmul ( sew ): '''Function to get illegal lmul with input sew. Args: sew (int): vsew register value, which can be 8, 16, 32, 64. Returns: list: illegal lmul with input sew, when sew == 8, return None. ''' if 8 == sew : return None if 16 == sew : return [ 'f8' ] if 32 == sew : return [ 'f4' , 'f8' ] if 64 == sew : return [ 'f2' , 'f4' , 'f8' ] vector_illegal_lmul_w ( sew ) Function to get illegal lmul values with input sew for widening and narrowing instructions. Parameters: Name Type Description Default sew int vsew register value, which can be 8, 16, 32, 64. required Returns: Type Description list illegal lmul with input sew for widening and narrowing instructions. Source code in rvpvp/utils/data.py def vector_illegal_lmul_w ( sew ): '''Function to get illegal lmul values with input sew for widening and narrowing instructions. Args: sew (int): vsew register value, which can be 8, 16, 32, 64. Returns: list: illegal lmul with input sew for widening and narrowing instructions. ''' if 8 == sew : return [ 8 ] if 16 == sew : return [ 'f8' , 8 ] if 32 == sew : return [ 'f4' , 'f8' , 8 ] if 64 == sew : return [ 'f2' , 'f4' , 'f8' , 8 ] vector_index_array ( eew , sew , vl ) Function to get a numpy ndarray of vl size to be used as indexes for index instructions. Parameters: Name Type Description Default eew int effective element width, used as index width. required sew int vsew register value, used as operand element width. required vl int vector length register value required Returns: Type Description numpy ndarray A linspace numpy ndarray between 0 and 2**20 multiplying with sew//8 with size equal to vl. Its dtype is uint in eew width. Source code in rvpvp/utils/data.py def vector_index_array ( eew , sew , vl ): '''Function to get a numpy ndarray of vl size to be used as indexes for index instructions. Args: eew (int): effective element width, used as index width. sew (int): vsew register value, used as operand element width. vl (int): vector length register value Returns: numpy ndarray: A linspace numpy ndarray between 0 and 2**20 multiplying with sew//8 with size equal to vl. Its dtype is uint in eew width. ''' return np . linspace ( 0 , 2 ** 20 , vl , dtype = bits_to_dtype_uint ( eew )) * ( sew // 8 ) vector_index_array_consecutive ( eew , sew , vl ) Function to get consecutive indexes for index instructions. Parameters: Name Type Description Default eew int effective element width, used as index width. required sew int vsew register value, used as operand element width. required vl int vector length register value required Returns: Type Description list A list 2 numpy ndarray. The first array has vl size of uint 0 in eew width. So the indexes are 0. The second array has elements of [0, 1, ..., vl-1]*(sew//8) of which the dtype is uint in eew width. They are consecutive indexes. Source code in rvpvp/utils/data.py def vector_index_array_consecutive ( eew , sew , vl ): '''Function to get consecutive indexes for index instructions. Args: eew (int): effective element width, used as index width. sew (int): vsew register value, used as operand element width. vl (int): vector length register value Returns: list: A list 2 numpy ndarray. The first array has vl size of uint 0 in eew width. So the indexes are 0. The second array has elements of [0, 1, ..., vl-1]*(sew//8) of which the dtype is uint in eew width. They are consecutive indexes. ''' index = [] index . append ( np . zeros ( vl , dtype = bits_to_dtype_uint ( eew ))) index . append ( np . linspace ( 0 , vl - 1 , vl , dtype = bits_to_dtype_uint ( eew )) * ( sew // 8 )) return index vector_index_array_misaligned ( eew , sew , vl ) Function to get misaligned indexes for index instructions. Parameters: Name Type Description Default eew int effective element width, used as index width. required sew int vsew register value, used as operand element width. required vl int vector length register value required Returns: Type Description numpy ndarray A numpy ndarray, its size is vl, its elements is computed by a linspace array between 0 and 0xff multiplying with (sew//8)*4 and adding 3, its dtype is uint in eew width. Source code in rvpvp/utils/data.py def vector_index_array_misaligned ( eew , sew , vl ): '''Function to get misaligned indexes for index instructions. Args: eew (int): effective element width, used as index width. sew (int): vsew register value, used as operand element width. vl (int): vector length register value Returns: numpy ndarray: A numpy ndarray, its size is vl, its elements is computed by a linspace array between 0 and 0xff multiplying with (sew//8)*4 and adding 3, its dtype is uint in eew width. ''' return np . linspace ( 0 , 0xff , vl , dtype = bits_to_dtype_uint ( eew )) * ( sew // 8 ) * 4 + 3 vector_lmul_list ( sew_t ) Function to get available lmul according to sew or sew and eew. Parameters: Name Type Description Default sew_t int, tuple, list If the type of sew_t is int, it is used as sew and eew. If the type of sew_t is tuple or list, the first element is used as sew, and second element is used as eew. required Returns: Type Description list The list includes avaliable lmul value when sew and eew are set by sew_t. Source code in rvpvp/utils/data.py def vector_lmul_list ( sew_t ): '''Function to get available lmul according to sew or sew and eew. Args: sew_t (int, tuple, list): If the type of sew_t is int, it is used as sew and eew. If the type of sew_t is tuple or list, the first element is used as sew, and second element is used as eew. Returns: list: The list includes avaliable lmul value when sew and eew are set by sew_t. ''' if type ( sew_t ) == int : sew = sew_t eew = sew elif type ( sew_t ) == tuple or type ( sew_t ) == list : sew = sew_t [ 0 ] eew = sew_t [ 1 ] if 8 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' , 'f4' , 'f8' ] if 16 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' , 'f4' ] if 32 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' ] if 64 == sew : tmp = [ 1 , 2 , 4 , 8 ] lmul_list = [] for i in tmp : if ( eew / sew * factor_lmul [ i ]) <= 8 and ( eew / factor_lmul [ i ]) <= 64 : lmul_list . append ( i ) return lmul_list vector_lmul_list_index_seg ( eew , sew , nf ) Function to get avaliable lmul for segment index instructions. Parameters: Name Type Description Default eew int Effective element width. required sew int Selected element width. required nf int nf field of segment instructions. required Returns: Type Description list The list includes avaliable lmul value with input eew, sew and nf for segment index instructions. Source code in rvpvp/utils/data.py def vector_lmul_list_index_seg ( eew , sew , nf ): '''Function to get avaliable lmul for segment index instructions. Args: eew (int): Effective element width. sew (int): Selected element width. nf (int): nf field of segment instructions. Returns: list: The list includes avaliable lmul value with input eew, sew and nf for segment index instructions. ''' if 8 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' , 'f4' , 'f8' ] if 16 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' , 'f4' ] if 32 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' ] if 64 == sew : tmp = [ 1 , 2 , 4 , 8 ] lmul_list = [] for i in tmp : if ( eew / sew * factor_lmul [ i ]) <= 8 and ( eew / factor_lmul [ i ]) <= 64 and ( nf * factor_lmul [ i ]) <= 8 : lmul_list . append ( i ) return lmul_list vector_lmul_list_seg ( eew , sew , nf ) Function to get avaliable lmul for segment instructions. Parameters: Name Type Description Default eew int Effective element width. required sew int Selected element width. required nf int nf field of segment instructions. required Returns: Type Description list The list includes avaliable lmul value with input eew, sew and nf for segment instructions. Source code in rvpvp/utils/data.py def vector_lmul_list_seg ( eew , sew , nf ): '''Function to get avaliable lmul for segment instructions. Args: eew (int): Effective element width. sew (int): Selected element width. nf (int): nf field of segment instructions. Returns: list: The list includes avaliable lmul value with input eew, sew and nf for segment instructions. ''' if 8 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' , 'f4' , 'f8' ] if 16 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' , 'f4' ] if 32 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' ] if 64 == sew : tmp = [ 1 , 2 , 4 , 8 ] lmul_list = [] for i in tmp : if ( eew / sew * factor_lmul [ i ]) <= 8 and ( eew / factor_lmul [ i ]) <= 64 and ( nf * eew / sew * factor_lmul [ i ]) <= 8 : lmul_list . append ( i ) return lmul_list vector_lmul_list_w ( sew ) Function to get available lmul with input sew for widening and narrowing instructions. Parameters: Name Type Description Default sew int vsew register value, which can be 8, 16, 32, 64. required Returns: Type Description list The list includes avaliable lmul value with input sew for widening and narrowing instructions. Source code in rvpvp/utils/data.py def vector_lmul_list_w ( sew ): '''Function to get available lmul with input sew for widening and narrowing instructions. Args: sew (int): vsew register value, which can be 8, 16, 32, 64. Returns: list: The list includes avaliable lmul value with input sew for widening and narrowing instructions. ''' if 8 == sew : return [ 1 , 2 , 4 , 'f2' , 'f4' , 'f8' ] if 16 == sew : return [ 1 , 2 , 4 , 'f2' , 'f4' ] if 32 == sew : return [ 1 , 2 , 4 , 'f2' ] if 64 == sew : return [ 1 , 2 , 4 ] vector_mask_array_first_masked ( vl ) Function used to generate mask bits of which the first bit is 0, others are 1 for rvv instruction. Parameters: Name Type Description Default vl int vl register value, which defines mask bits amount in this function. required Returns: Type Description numpy ndarray A numpy ndarray of which the first bit of first element is 0, others are 1, its dtype is numpy.uint8, its size is the integer which is rounded up to after vl is divided by 8. Source code in rvpvp/utils/data.py def vector_mask_array_first_masked ( vl ): '''Function used to generate mask bits of which the first bit is 0, others are 1 for rvv instruction. Args: vl (int): vl register value, which defines mask bits amount in this function. Returns: numpy ndarray: A numpy ndarray of which the first bit of first element is 0, others are 1, its dtype is numpy.uint8, its size is the integer which is rounded up to after vl is divided by 8. ''' mask = np . ones ( vl , dtype = np . uint8 ) mask [ 0 ] = 0 mask = np . packbits ( mask , bitorder = 'little' ) return mask vector_mask_array_last_masked ( vl ) Function used to generate mask bits of which the vlth bit is 0, others are 1 for rvv instruction. Parameters: Name Type Description Default vl int vl register value, which defines mask bits amount in this function. required Returns: Type Description numpy ndarray A numpy ndarray of which the vlth bit is 0, others are 1, its dtype is numpy.uint8, its size is the integer which is rounded up to after vl is divided by 8. Source code in rvpvp/utils/data.py def vector_mask_array_last_masked ( vl ): '''Function used to generate mask bits of which the vlth bit is 0, others are 1 for rvv instruction. Args: vl (int): vl register value, which defines mask bits amount in this function. Returns: numpy ndarray: A numpy ndarray of which the vlth bit is 0, others are 1, its dtype is numpy.uint8, its size is the integer which is rounded up to after vl is divided by 8. ''' mask = np . ones ( vl , dtype = np . uint8 ) mask [ vl - 1 ] = 0 mask = np . packbits ( mask , bitorder = 'little' ) return mask vector_mask_array_random ( vl ) Function used to generate random mask bits for rvv instructions. Parameters: Name Type Description Default vl int vl register value, which defines mask bits amount in this function. required Returns: Type Description numpy ndarray A random numpy ndarray, its dtype is numpy.uint8, its size is the integer which is rounded up to after vl is divided by 8. The bits above vl are 0. Source code in rvpvp/utils/data.py def vector_mask_array_random ( vl ): '''Function used to generate random mask bits for rvv instructions. Args: vl (int): vl register value, which defines mask bits amount in this function. Returns: numpy ndarray: A random numpy ndarray, its dtype is numpy.uint8, its size is the integer which is rounded up to after vl is divided by 8. The bits above vl are 0. ''' mask = np . array ( np . random . randint ( 0 , 255 , np . ceil ( vl / 8 ) . astype ( np . int16 )), dtype = np . uint8 ) mask = np . unpackbits ( mask , bitorder = 'little' )[ 0 : vl ] mask = np . packbits ( mask , bitorder = 'little' ) return mask vector_mask_array_zero ( vl ) Function used to generate zero mask bits for rvv instruction. Parameters: Name Type Description Default vl int vl register value, which defines mask bits amount in this function. required Returns: Type Description numpy ndarray A zero numpy ndarray, its dtype is numpy.uint8, its size is the integer which is rounded up to after vl is divided by 8. Source code in rvpvp/utils/data.py def vector_mask_array_zero ( vl ): '''Function used to generate zero mask bits for rvv instruction. Args: vl (int): vl register value, which defines mask bits amount in this function. Returns: numpy ndarray: A zero numpy ndarray, its dtype is numpy.uint8, its size is the integer which is rounded up to after vl is divided by 8. ''' mask = np . zeros ( int ( np . ceil ( vl / 8 )), dtype = np . uint8 ) return mask vector_sew_list_neq_eew ( eew ) Function to get available vsew values which don't equal to eew. Parameters: Name Type Description Default eew int The present eew value, which can be 8, 16, 32, 64. required Returns: Type Description list A list of available vsew values which don't equal to eew. The available vsew values are 8, 16, 32, 64. Source code in rvpvp/utils/data.py def vector_sew_list_neq_eew ( eew ): '''Function to get available vsew values which don't equal to eew. Args: eew (int): The present eew value, which can be 8, 16, 32, 64. Returns: list: A list of available vsew values which don't equal to eew. The available vsew values are 8, 16, 32, 64. ''' if 8 == eew : return [ 16 , 32 , 64 ] elif 16 == eew : return [ 8 , 32 , 64 ] elif 32 == eew : return [ 8 , 16 , 64 ] elif 64 == eew : return [ 8 , 16 , 32 ] vector_stride_list_random ( eew ) Function to get a list of 5 random int numbers between 0 and 0xff*eew. Parameters: Name Type Description Default eew int effective element width. required Returns: Type Description list A list of 5 random int numbers between 0 and 0xff*eew. Random numbers are generated between 0 and 0xff first, then multiply with eew. Source code in rvpvp/utils/data.py def vector_stride_list_random ( eew ): '''Function to get a list of 5 random int numbers between 0 and 0xff*eew. Args: eew (int): effective element width. Returns: list: A list of 5 random int numbers between 0 and 0xff*eew. Random numbers are generated between 0 and 0xff first, then multiply with eew. ''' return list ( np . random . uniform ( 0 , 0xff , 5 ) . astype ( int ) * eew ) vector_stride_list_random_ls_stride ( vl , eew , nf = 1 ) Function to get a list of random int numbers to be used as stride of vector stride instructions. Parameters: Name Type Description Default vl int vector length register value required eew int effective element length required nf int nf field in vector instruction for segment instructions, default 1. 1 Returns: Type Description list Stride numbers are computed by 0, eew, vl*nf multiplying with eew. If nf > 1, a random int number between 0 and nf and a random int number between nf+1 and 16 multiply with eew and then are appended into the list. Source code in rvpvp/utils/data.py def vector_stride_list_random_ls_stride ( vl , eew , nf = 1 ): '''Function to get a list of random int numbers to be used as stride of vector stride instructions. Args: vl (int): vector length register value eew (int): effective element length nf (int): nf field in vector instruction for segment instructions, default 1. Returns: list: Stride numbers are computed by 0, eew, vl*nf multiplying with eew. If nf > 1, a random int number between 0 and nf and a random int number between nf+1 and 16 multiply with eew and then are appended into the list. ''' stride_list = [ 0 , eew * nf , vl * nf * eew ] if nf > 1 : stride_list . append ( np . random . randint ( 0 , nf ) * eew ) stride_list . append ( np . random . randint ( nf + 1 , 16 ) * eew ) return stride_list vector_vl_list ( lmul , ebits , vlen ) Functions to get vl value based on vlen, sew, lmul Parameters: Name Type Description Default lmul int or str vlmul register value required ebits int element bits length, which equals to vsew value. required vlen int rvv register length required Returns: Type Description list A list including 1, vlmax, vlmax-1 and a value between 1 and vlmax-1. If two values are equal, keep one value in the list. Source code in rvpvp/utils/data.py def vector_vl_list ( lmul , ebits , vlen ): '''Functions to get vl value based on vlen, sew, lmul Args: lmul (int or str): vlmul register value ebits (int): element bits length, which equals to vsew value. vlen (int): rvv register length Returns: list: A list including 1, vlmax, vlmax-1 and a value between 1 and vlmax-1. If two values are equal, keep one value in the list. ''' max = int ( vlen * factor_lmul [ lmul ] / ebits ) if 1 < max : if 1 < max - 1 : if 2 < max - 1 : mid = np . random . randint ( 2 , max - 1 ) return [ 1 , mid , max - 1 , max ] else : return [ 1 , max - 1 , max ] else : return [ 1 , max ] else : return [ 1 ] vector_vl_list_ls ( lmul , sew , eew , vlen ) Function to get vl list for rvv load-store instruction Parameters: Name Type Description Default lmul int or str vlmul register value required sew int vsew register value required eew int effective element width set by load-store instruction required vlen int rvv register length required Returns: Type Description list A list including test vl values for load-store instruction. Source code in rvpvp/utils/data.py def vector_vl_list_ls ( lmul , sew , eew , vlen ): '''Function to get vl list for rvv load-store instruction Args: lmul (int or str): vlmul register value sew (int): vsew register value eew (int): effective element width set by load-store instruction vlen (int): rvv register length Returns: list: A list including test vl values for load-store instruction. ''' emul = sew / eew * factor_lmul [ lmul ] emul = int ( emul if emul >= 1 else 1 ) sum = int ( vlen * factor_lmul [ lmul ] / sew ) esum = int ( vlen * emul / eew ) mid = np . random . randint ( 2 , sum - 1 ) if sum <= esum : return [ 1 , mid , sum - 1 , sum ] else : esum = int ( vlen * factor_lmul [ lmul ] / eew ) vl_list = [ 1 ] for i in range ( 1 , emul + 1 ): isum = int ( vlen * i / eew ) vl_list . append ( isum - 1 ) vl_list . append ( isum ) return vl_list vector_vl_list_ls_random ( lmul , sew , eew , vlen ) Functions to get random vl list for load&store cases, based on lmul, sew, eew, vlen. Parameters: Name Type Description Default lmul int or str vlmul register value required sew int vsew register value required eew int effective element width required vlen int rvv vector register length required Returns: Type Description list A list including 10 random int numbers between 1 and vlmax Source code in rvpvp/utils/data.py def vector_vl_list_ls_random ( lmul , sew , eew , vlen ): '''Functions to get random vl list for load&store cases, based on lmul, sew, eew, vlen. Args: lmul (int or str): vlmul register value sew (int): vsew register value eew (int): effective element width vlen (int): rvv vector register length Returns: list: A list including 10 random int numbers between 1 and vlmax ''' emul = sew / eew * factor_lmul [ lmul ] emul = int ( emul if emul >= 1 else 1 ) sum = int ( vlen * factor_lmul [ lmul ] / sew ) esum = int ( vlen * emul / eew ) mid = np . random . randint ( 2 , sum - 1 ) minSum = min ( sum , esum ) return list ( np . unique ( np . random . uniform ( 1 , minSum , 10 )) . astype ( int )) vector_vl_list_ls_seg ( lmul , sew , eew , vlen ) Function to get vl list for rvv segment load-store instruction Parameters: Name Type Description Default lmul int or str vlmul register value required sew int vsew register value required eew int effective element width set by load-store instruction required vlen int rvv register length required Returns: Type Description list A list including test vl values for segment load-store instruction. Source code in rvpvp/utils/data.py def vector_vl_list_ls_seg ( lmul , sew , eew , vlen ): '''Function to get vl list for rvv segment load-store instruction Args: lmul (int or str): vlmul register value sew (int): vsew register value eew (int): effective element width set by load-store instruction vlen (int): rvv register length Returns: list: A list including test vl values for segment load-store instruction. ''' emul = sew / eew * factor_lmul [ lmul ] sum = int ( vlen * factor_lmul [ lmul ] / sew ) esum = int ( vlen * emul / eew ) mid = np . random . randint ( 2 , sum - 1 ) if sum <= esum : return [ 1 , mid , sum - 1 , sum ] else : esum = int ( vlen * factor_lmul [ lmul ] / eew ) vl_list = [ 1 ] if emul < 1 : return [ 1 , esum - 1 , esum ] else : for i in range ( 1 , int ( emul + 1 )): isum = int ( vlen * i / eew ) vl_list . append ( isum - 1 ) vl_list . append ( isum ) return vl_list vector_vstart_list_linspace ( vl ) Function to get a list of int numbers to be used as vstart in test cases. Parameters: Name Type Description Default vl int vector length register value required Returns: Type Description list A list of int number between 0 and vl-1. The length of the list is computed by vl//10. Source code in rvpvp/utils/data.py def vector_vstart_list_linspace ( vl ): '''Function to get a list of int numbers to be used as vstart in test cases. Args: vl (int): vector length register value Returns: list: A list of int number between 0 and vl-1. The length of the list is computed by vl//10. ''' return list ( np . unique ( np . linspace ( 0 , vl - 1 , vl // 10 ) . astype ( int ))) vector_vstart_list_random ( vl ) Function to get a list of 5 random int numbers between 0 and vl-1 to be used as vstart. Parameters: Name Type Description Default vl int vector length register value required Returns: Type Description list A list of 5 random int number between 0 and vl-1. Source code in rvpvp/utils/data.py def vector_vstart_list_random ( vl ) : '''Function to get a list of 5 random int numbers between 0 and vl-1 to be used as vstart. Args: vl (int): vector length register value Returns: list: A list of 5 random int number between 0 and vl-1. ''' return list ( np . unique ( np . random . uniform ( 0 , vl - 1 , 5 ) . astype ( int )))","title":"Test Data"},{"location":"reference/functions/data/#generate-data-for-test-cases","text":"You can use functions and lists in this module to generate data for cases.","title":"Generate data for test cases"},{"location":"reference/functions/data/#rvpvp.utils.data.scalar_float_list_special","text":"Function to generate a list special float numbers of which the data type is depended on sew. Parameters: Name Type Description Default sew int sew decides the element width and data type for special float numbers. 16 - float16 32 - float32 64 - float64 required Returns: Type Description list A list of 8 numpy ndarrays. When sew == 16, return the result of special_fp16(). When sew == 32, return the result of special_fp32(). When sew == 64, return the result of special_fp64(). Source code in rvpvp/utils/data.py def scalar_float_list_special ( sew ): '''Function to generate a list special float numbers of which the data type is depended on sew. Args: sew (int): sew decides the element width and data type for special float numbers. 16 - float16 32 - float32 64 - float64 Returns: list: A list of 8 numpy ndarrays. When sew == 16, return the result of special_fp16(). When sew == 32, return the result of special_fp32(). When sew == 64, return the result of special_fp64(). ''' if sew == 16 : return special_fp16 () if sew == 32 : return special_fp32 () if sew == 64 : return special_fp64 ()","title":"scalar_float_list_special()"},{"location":"reference/functions/data/#rvpvp.utils.data.scalar_float_random","text":"Function to return a numpy ndarray of random float numbers. Parameters: Name Type Description Default sew int vsew register value, float number width. It can be 16, 32, 64 corresponding to float16, float32 and float64. required vl int vector length, the size of numpy ndarray. required Returns: Type Description numpy ndarray A numpy ndarray with random numbers in the full range of float data type. Its size is vl. Its dtype is float16, float32 or float64 corresponding to the input width, sew. Exceptions: Type Description ValueError If sew isn't equal to 16, 32, 64. Source code in rvpvp/utils/data.py def scalar_float_random ( sew , vl ): '''Function to return a numpy ndarray of random float numbers. Args: sew (int): vsew register value, float number width. It can be 16, 32, 64 corresponding to float16, float32 and float64. vl (int): vector length, the size of numpy ndarray. Returns: numpy ndarray: A numpy ndarray with random numbers in the full range of float data type. Its size is vl. Its dtype is float16, float32 or float64 corresponding to the input width, sew. Raises: ValueError: If sew isn't equal to 16, 32, 64. ''' if sew == 16 : num = np . random . randint ( 0 , 0x10000 , size = vl , dtype = np . uint16 ) num . dtype = np . float16 elif sew == 32 : num = np . random . randint ( 0 , 0x100000000 , size = vl , dtype = np . uint32 ) num . dtype = np . float32 elif sew == 64 : num = np . random . randint ( 0 , 1 << 64 , size = vl , dtype = np . uint64 ) num . dtype = np . float64 else : raise ValueError ( f ' { sew } is not a good option for sew.' ) return num","title":"scalar_float_random()"},{"location":"reference/functions/data/#rvpvp.utils.data.scalar_int_random","text":"Function to return a numpy ndarray of random int numbers. Parameters: Name Type Description Default sew int vsew register value, int number width. It can be 8, 16, 32, 64 corresponding to int8, int16, required vl int vector length, the size of numpy ndarray. required Returns: Type Description numpy ndarray A numpy ndarray with random numbers in the full range of int data type. Its size is vl. Its dtype is int8, int16, int32 or int64 corresponding to the input width, sew. Exceptions: Type Description ValueError If sew isn't equal to 8, 16, 32, 64. Source code in rvpvp/utils/data.py def scalar_int_random ( sew , vl ): '''Function to return a numpy ndarray of random int numbers. Args: sew (int): vsew register value, int number width. It can be 8, 16, 32, 64 corresponding to int8, int16, int32, int64. vl (int): vector length, the size of numpy ndarray. Returns: numpy ndarray: A numpy ndarray with random numbers in the full range of int data type. Its size is vl. Its dtype is int8, int16, int32 or int64 corresponding to the input width, sew. Raises: ValueError: If sew isn't equal to 8, 16, 32, 64. ''' if sew == 8 : num = np . random . randint ( 0 , 0x100 , size = vl , dtype = np . uint8 ) num . dtype = np . int8 elif sew == 16 : num = np . random . randint ( 0 , 0x10000 , size = vl , dtype = np . uint16 ) num . dtype = np . int16 elif sew == 32 : num = np . random . randint ( 0 , 0x100000000 , size = vl , dtype = np . uint32 ) num . dtype = np . int32 elif sew == 64 : num = np . random . randint ( 0 , 1 << 64 , size = vl , dtype = np . uint64 ) num . dtype = np . int64 else : raise ValueError ( f ' { sew } is not a good option for sew.' ) return num","title":"scalar_int_random()"},{"location":"reference/functions/data/#rvpvp.utils.data.scalar_uint_random","text":"Function to return a numpy ndarray of random uint numbers. Parameters: Name Type Description Default sew int vsew register value, int number width. It can be 8, 16, 32, 64 corresponding to uint8, uint16, required vl int vector length, the size of numpy ndarray. required Returns: Type Description numpy ndarray A numpy ndarray with random numbers in the full range of uint data type. Its size is vl. Its dtype is uint8, uint16, uint32 or uint64 corresponding to the input width, sew. Exceptions: Type Description ValueError If sew isn't equal to 8, 16, 32, 64. Source code in rvpvp/utils/data.py def scalar_uint_random ( sew , vl ): '''Function to return a numpy ndarray of random uint numbers. Args: sew (int): vsew register value, int number width. It can be 8, 16, 32, 64 corresponding to uint8, uint16, uint32, uint64. vl (int): vector length, the size of numpy ndarray. Returns: numpy ndarray: A numpy ndarray with random numbers in the full range of uint data type. Its size is vl. Its dtype is uint8, uint16, uint32 or uint64 corresponding to the input width, sew. Raises: ValueError: If sew isn't equal to 8, 16, 32, 64. ''' if sew == 8 : num = np . random . randint ( 0 , 0x100 , size = vl , dtype = np . uint8 ) elif sew == 16 : num = np . random . randint ( 0 , 0x10000 , size = vl , dtype = np . uint16 ) elif sew == 32 : num = np . random . randint ( 0 , 0x100000000 , size = vl , dtype = np . uint32 ) elif sew == 64 : num = np . random . randint ( 0 , 1 << 64 , size = vl , dtype = np . uint64 ) else : raise ValueError ( f ' { sew } is not a good option for sew.' ) return num","title":"scalar_uint_random()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_float_array_special","text":"Function to generate a special float numpy ndarray of which the data type is decided by sew. Parameters: Name Type Description Default sew int sew decides the element width and data type for special float numbers. 16 - float16 32 - float32 64 - float64 required Returns: Type Description numpy ndarray When sew == 16, return the result of special_v_fp16(). When sew == 32, return the result of special_v_fp32(). When sew == 64, return the result of special_v_fp64(). Source code in rvpvp/utils/data.py def vector_float_array_special ( sew ): '''Function to generate a special float numpy ndarray of which the data type is decided by sew. Args: sew (int): sew decides the element width and data type for special float numbers. 16 - float16 32 - float32 64 - float64 Returns: numpy ndarray: When sew == 16, return the result of special_v_fp16(). When sew == 32, return the result of special_v_fp32(). When sew == 64, return the result of special_v_fp64(). ''' if sew == 16 : return special_v_fp16 () if sew == 32 : return special_v_fp32 () if sew == 64 : return special_v_fp64 ()","title":"vector_float_array_special()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_float_array_special_fp16_vv","text":"Function to generate a list of 2 numpy ndarrays which include 32 special float16 numbers. Returns: Type Description list The list includes 2 numpy ndarrays. There are 32 special float16 numbers in every ndarray. The corresponding elements pairs in these ndarrays are different and comprehensive. So users can use these two ndarrays to test the results between two special float16 numbers. Source code in rvpvp/utils/data.py def vector_float_array_special_fp16_vv (): '''Function to generate a list of 2 numpy ndarrays which include 32 special float16 numbers. Returns: list: The list includes 2 numpy ndarrays. There are 32 special float16 numbers in every ndarray. The corresponding elements pairs in these ndarrays are different and comprehensive. So users can use these two ndarrays to test the results between two special float16 numbers. ''' # special float table -0 , inf , -inf , nan , 0.1 , 10 , 65500 , 6.104e-05, 6.e-08 fpt0 = np . array ([[ 0x0000 ] * 6 , [ 0x8000 , 0x7c00 , 0x7e00 , 0x7bff , 0x0400 , 0x0001 ]], dtype = np . int16 ) fpt1 = np . array ([[ 0x7c00 ] * 8 , [ 0x7c00 , 0xfc00 , 0x7e00 , 0x2e66 , 0x4900 , 0x7bff , 0x0400 , 0x0001 ]], dtype = np . int16 ) fpt2 = np . array ([[ 0x7e00 ] * 6 , [ 0x7e00 , 0x2e66 , 0x4900 , 0x7bff , 0x0400 , 0x0001 ]], dtype = np . int16 ) fpt3 = np . array ([[ 0x2e66 ] * 3 , [ 0x7bff , 0x0400 , 0x0001 ]], dtype = np . int16 ) fpt4 = np . array ([[ 0x4900 ] * 3 , [ 0x7bff , 0x0400 , 0x0001 ]], dtype = np . int16 ) fpt5 = np . array ([[ 0x7bff ] * 3 , [ 0x7bff , 0x0400 , 0x0001 ]], dtype = np . int16 ) fpt6 = np . array ([[ 0x0400 ] * 2 , [ 0x0400 , 0x0001 ]], dtype = np . int16 ) fpt7 = np . array ([[ 0x0001 ] * 1 , [ 0x0001 ]], dtype = np . int16 ) fpt_data = np . concatenate (( fpt0 , fpt1 , fpt2 , fpt3 , fpt4 , fpt5 , fpt6 , fpt7 ), axis = 1 ) fpt_data . dtype = np . float16 return [ fpt_data [ 0 ], fpt_data [ 1 ] ]","title":"vector_float_array_special_fp16_vv()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_float_array_special_fp32_vv","text":"Function to generate a list of 2 numpy ndarrays which include 32 special float32 numbers. Returns: Type Description list The list includes 2 numpy ndarrays. There are 32 special float32 numbers in every ndarray. The corresponding elements pairs in these ndarrays are different and comprehensive. So users can use these two ndarrays to test the results between two special float32 numbers. Source code in rvpvp/utils/data.py def vector_float_array_special_fp32_vv (): '''Function to generate a list of 2 numpy ndarrays which include 32 special float32 numbers. Returns: list: The list includes 2 numpy ndarrays. There are 32 special float32 numbers in every ndarray. The corresponding elements pairs in these ndarrays are different and comprehensive. So users can use these two ndarrays to test the results between two special float32 numbers. ''' # special float table -0 , inf , -inf , nan , 0.1 , 10 , 3.40282e+38, 1.1755e-38, 1e-45 fpt0 = np . array ([[ 0x00000000 ] * 6 , [ 0x80000000 , 0x7f800000 , 0x7fc00000 , 0x7f7fffff , 0x00800000 , 0x00000001 ]], dtype = np . int32 ) fpt1 = np . array ([[ 0x7f800000 ] * 8 , [ 0x7f800000 , 0xff800000 , 0x7fc00000 , 0x3dcccccd , 0x41200000 , 0x7f7fffff , 0x00800000 , 0x00000001 ]], dtype = np . int32 ) fpt2 = np . array ([[ 0x7fc00000 ] * 6 , [ 0x7fc00000 , 0x3dcccccd , 0x41200000 , 0x7f7fffff , 0x00800000 , 0x00000001 ]], dtype = np . int32 ) fpt3 = np . array ([[ 0x3dcccccd ] * 3 , [ 0x7f7fffff , 0x00800000 , 0x00000001 ]], dtype = np . int32 ) fpt4 = np . array ([[ 0x41200000 ] * 3 , [ 0x7f7fffff , 0x00800000 , 0x00000001 ]], dtype = np . int32 ) fpt5 = np . array ([[ 0x7f7fffff ] * 3 , [ 0x7f7fffff , 0x00800000 , 0x00000001 ]], dtype = np . int32 ) fpt6 = np . array ([[ 0x00800000 ] * 2 , [ 0x00800000 , 0x00000001 ]], dtype = np . int32 ) fpt7 = np . array ([[ 0x00000001 ] * 1 , [ 0x00000001 ]], dtype = np . int32 ) fpt_data = np . concatenate (( fpt0 , fpt1 , fpt2 , fpt3 , fpt4 , fpt5 , fpt6 , fpt7 ), axis = 1 ) fpt_data . dtype = np . float32 return [ fpt_data [ 0 ], fpt_data [ 1 ] ]","title":"vector_float_array_special_fp32_vv()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_float_array_special_fp64_vv","text":"Function to generate a list of 2 numpy ndarrays which include 32 special float64 numbers. Returns: Type Description list The list includes 2 numpy ndarrays. There are 32 special float64 numbers in every ndarray. The corresponding elements pairs in these ndarrays are different and comprehensive. So users can use these two ndarrays to test the results between two special float64 numbers. Source code in rvpvp/utils/data.py def vector_float_array_special_fp64_vv (): '''Function to generate a list of 2 numpy ndarrays which include 32 special float64 numbers. Returns: list: The list includes 2 numpy ndarrays. There are 32 special float64 numbers in every ndarray. The corresponding elements pairs in these ndarrays are different and comprehensive. So users can use these two ndarrays to test the results between two special float64 numbers. ''' # special float table -0 , inf , -inf , nan , 0.1 , 10 , 1.79769313e+308, 2.22507386e-308, 5.e-324 fpt0 = np . array ([[ 0x0000000000000000 ] * 6 , [ 0x8000000000000000 , 0x7ff0000000000000 , 0x7ff8000000000000 , 0x7fefffffffffffff , 0x0010000000000000 , 0x0000000000000001 ]], dtype = np . uint64 ) fpt1 = np . array ([[ 0x7ff0000000000000 ] * 8 , [ 0x7ff0000000000000 , 0xfff0000000000000 , 0x7ff8000000000000 , 0x3fb999999999999a , 0x4024000000000000 , 0x7fefffffffffffff , 0x0010000000000000 , 0x0000000000000001 ]], dtype = np . uint64 ) fpt2 = np . array ([[ 0x7ff8000000000000 ] * 6 , [ 0x7ff8000000000000 , 0x3fb999999999999a , 0x4024000000000000 , 0x7fefffffffffffff , 0x0010000000000000 , 0x0000000000000001 ]], dtype = np . uint64 ) fpt3 = np . array ([[ 0x3fb999999999999a ] * 3 , [ 0x7fefffffffffffff , 0x0010000000000000 , 0x0000000000000001 ]], dtype = np . uint64 ) fpt4 = np . array ([[ 0x4024000000000000 ] * 3 , [ 0x7fefffffffffffff , 0x0010000000000000 , 0x0000000000000001 ]], dtype = np . uint64 ) fpt5 = np . array ([[ 0x7fefffffffffffff ] * 3 , [ 0x7fefffffffffffff , 0x0010000000000000 , 0x0000000000000001 ]], dtype = np . uint64 ) fpt6 = np . array ([[ 0x0010000000000000 ] * 2 , [ 0x0010000000000000 , 0x0000000000000001 ]], dtype = np . uint64 ) fpt7 = np . array ([[ 0x0000000000000001 ] * 1 , [ 0x0000000000000001 ]], dtype = np . uint64 ) fpt_data = np . concatenate (( fpt0 , fpt1 , fpt2 , fpt3 , fpt4 , fpt5 , fpt6 , fpt7 ), axis = 1 ) fpt_data . dtype = np . float64 return [ fpt_data [ 0 ], fpt_data [ 1 ] ]","title":"vector_float_array_special_fp64_vv()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_illegal_lmul","text":"Function to get illegal lmul with input sew. Parameters: Name Type Description Default sew int vsew register value, which can be 8, 16, 32, 64. required Returns: Type Description list illegal lmul with input sew, when sew == 8, return None. Source code in rvpvp/utils/data.py def vector_illegal_lmul ( sew ): '''Function to get illegal lmul with input sew. Args: sew (int): vsew register value, which can be 8, 16, 32, 64. Returns: list: illegal lmul with input sew, when sew == 8, return None. ''' if 8 == sew : return None if 16 == sew : return [ 'f8' ] if 32 == sew : return [ 'f4' , 'f8' ] if 64 == sew : return [ 'f2' , 'f4' , 'f8' ]","title":"vector_illegal_lmul()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_illegal_lmul_w","text":"Function to get illegal lmul values with input sew for widening and narrowing instructions. Parameters: Name Type Description Default sew int vsew register value, which can be 8, 16, 32, 64. required Returns: Type Description list illegal lmul with input sew for widening and narrowing instructions. Source code in rvpvp/utils/data.py def vector_illegal_lmul_w ( sew ): '''Function to get illegal lmul values with input sew for widening and narrowing instructions. Args: sew (int): vsew register value, which can be 8, 16, 32, 64. Returns: list: illegal lmul with input sew for widening and narrowing instructions. ''' if 8 == sew : return [ 8 ] if 16 == sew : return [ 'f8' , 8 ] if 32 == sew : return [ 'f4' , 'f8' , 8 ] if 64 == sew : return [ 'f2' , 'f4' , 'f8' , 8 ]","title":"vector_illegal_lmul_w()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_index_array","text":"Function to get a numpy ndarray of vl size to be used as indexes for index instructions. Parameters: Name Type Description Default eew int effective element width, used as index width. required sew int vsew register value, used as operand element width. required vl int vector length register value required Returns: Type Description numpy ndarray A linspace numpy ndarray between 0 and 2**20 multiplying with sew//8 with size equal to vl. Its dtype is uint in eew width. Source code in rvpvp/utils/data.py def vector_index_array ( eew , sew , vl ): '''Function to get a numpy ndarray of vl size to be used as indexes for index instructions. Args: eew (int): effective element width, used as index width. sew (int): vsew register value, used as operand element width. vl (int): vector length register value Returns: numpy ndarray: A linspace numpy ndarray between 0 and 2**20 multiplying with sew//8 with size equal to vl. Its dtype is uint in eew width. ''' return np . linspace ( 0 , 2 ** 20 , vl , dtype = bits_to_dtype_uint ( eew )) * ( sew // 8 )","title":"vector_index_array()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_index_array_consecutive","text":"Function to get consecutive indexes for index instructions. Parameters: Name Type Description Default eew int effective element width, used as index width. required sew int vsew register value, used as operand element width. required vl int vector length register value required Returns: Type Description list A list 2 numpy ndarray. The first array has vl size of uint 0 in eew width. So the indexes are 0. The second array has elements of [0, 1, ..., vl-1]*(sew//8) of which the dtype is uint in eew width. They are consecutive indexes. Source code in rvpvp/utils/data.py def vector_index_array_consecutive ( eew , sew , vl ): '''Function to get consecutive indexes for index instructions. Args: eew (int): effective element width, used as index width. sew (int): vsew register value, used as operand element width. vl (int): vector length register value Returns: list: A list 2 numpy ndarray. The first array has vl size of uint 0 in eew width. So the indexes are 0. The second array has elements of [0, 1, ..., vl-1]*(sew//8) of which the dtype is uint in eew width. They are consecutive indexes. ''' index = [] index . append ( np . zeros ( vl , dtype = bits_to_dtype_uint ( eew ))) index . append ( np . linspace ( 0 , vl - 1 , vl , dtype = bits_to_dtype_uint ( eew )) * ( sew // 8 )) return index","title":"vector_index_array_consecutive()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_index_array_misaligned","text":"Function to get misaligned indexes for index instructions. Parameters: Name Type Description Default eew int effective element width, used as index width. required sew int vsew register value, used as operand element width. required vl int vector length register value required Returns: Type Description numpy ndarray A numpy ndarray, its size is vl, its elements is computed by a linspace array between 0 and 0xff multiplying with (sew//8)*4 and adding 3, its dtype is uint in eew width. Source code in rvpvp/utils/data.py def vector_index_array_misaligned ( eew , sew , vl ): '''Function to get misaligned indexes for index instructions. Args: eew (int): effective element width, used as index width. sew (int): vsew register value, used as operand element width. vl (int): vector length register value Returns: numpy ndarray: A numpy ndarray, its size is vl, its elements is computed by a linspace array between 0 and 0xff multiplying with (sew//8)*4 and adding 3, its dtype is uint in eew width. ''' return np . linspace ( 0 , 0xff , vl , dtype = bits_to_dtype_uint ( eew )) * ( sew // 8 ) * 4 + 3","title":"vector_index_array_misaligned()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_lmul_list","text":"Function to get available lmul according to sew or sew and eew. Parameters: Name Type Description Default sew_t int, tuple, list If the type of sew_t is int, it is used as sew and eew. If the type of sew_t is tuple or list, the first element is used as sew, and second element is used as eew. required Returns: Type Description list The list includes avaliable lmul value when sew and eew are set by sew_t. Source code in rvpvp/utils/data.py def vector_lmul_list ( sew_t ): '''Function to get available lmul according to sew or sew and eew. Args: sew_t (int, tuple, list): If the type of sew_t is int, it is used as sew and eew. If the type of sew_t is tuple or list, the first element is used as sew, and second element is used as eew. Returns: list: The list includes avaliable lmul value when sew and eew are set by sew_t. ''' if type ( sew_t ) == int : sew = sew_t eew = sew elif type ( sew_t ) == tuple or type ( sew_t ) == list : sew = sew_t [ 0 ] eew = sew_t [ 1 ] if 8 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' , 'f4' , 'f8' ] if 16 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' , 'f4' ] if 32 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' ] if 64 == sew : tmp = [ 1 , 2 , 4 , 8 ] lmul_list = [] for i in tmp : if ( eew / sew * factor_lmul [ i ]) <= 8 and ( eew / factor_lmul [ i ]) <= 64 : lmul_list . append ( i ) return lmul_list","title":"vector_lmul_list()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_lmul_list_index_seg","text":"Function to get avaliable lmul for segment index instructions. Parameters: Name Type Description Default eew int Effective element width. required sew int Selected element width. required nf int nf field of segment instructions. required Returns: Type Description list The list includes avaliable lmul value with input eew, sew and nf for segment index instructions. Source code in rvpvp/utils/data.py def vector_lmul_list_index_seg ( eew , sew , nf ): '''Function to get avaliable lmul for segment index instructions. Args: eew (int): Effective element width. sew (int): Selected element width. nf (int): nf field of segment instructions. Returns: list: The list includes avaliable lmul value with input eew, sew and nf for segment index instructions. ''' if 8 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' , 'f4' , 'f8' ] if 16 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' , 'f4' ] if 32 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' ] if 64 == sew : tmp = [ 1 , 2 , 4 , 8 ] lmul_list = [] for i in tmp : if ( eew / sew * factor_lmul [ i ]) <= 8 and ( eew / factor_lmul [ i ]) <= 64 and ( nf * factor_lmul [ i ]) <= 8 : lmul_list . append ( i ) return lmul_list","title":"vector_lmul_list_index_seg()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_lmul_list_seg","text":"Function to get avaliable lmul for segment instructions. Parameters: Name Type Description Default eew int Effective element width. required sew int Selected element width. required nf int nf field of segment instructions. required Returns: Type Description list The list includes avaliable lmul value with input eew, sew and nf for segment instructions. Source code in rvpvp/utils/data.py def vector_lmul_list_seg ( eew , sew , nf ): '''Function to get avaliable lmul for segment instructions. Args: eew (int): Effective element width. sew (int): Selected element width. nf (int): nf field of segment instructions. Returns: list: The list includes avaliable lmul value with input eew, sew and nf for segment instructions. ''' if 8 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' , 'f4' , 'f8' ] if 16 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' , 'f4' ] if 32 == sew : tmp = [ 1 , 2 , 4 , 8 , 'f2' ] if 64 == sew : tmp = [ 1 , 2 , 4 , 8 ] lmul_list = [] for i in tmp : if ( eew / sew * factor_lmul [ i ]) <= 8 and ( eew / factor_lmul [ i ]) <= 64 and ( nf * eew / sew * factor_lmul [ i ]) <= 8 : lmul_list . append ( i ) return lmul_list","title":"vector_lmul_list_seg()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_lmul_list_w","text":"Function to get available lmul with input sew for widening and narrowing instructions. Parameters: Name Type Description Default sew int vsew register value, which can be 8, 16, 32, 64. required Returns: Type Description list The list includes avaliable lmul value with input sew for widening and narrowing instructions. Source code in rvpvp/utils/data.py def vector_lmul_list_w ( sew ): '''Function to get available lmul with input sew for widening and narrowing instructions. Args: sew (int): vsew register value, which can be 8, 16, 32, 64. Returns: list: The list includes avaliable lmul value with input sew for widening and narrowing instructions. ''' if 8 == sew : return [ 1 , 2 , 4 , 'f2' , 'f4' , 'f8' ] if 16 == sew : return [ 1 , 2 , 4 , 'f2' , 'f4' ] if 32 == sew : return [ 1 , 2 , 4 , 'f2' ] if 64 == sew : return [ 1 , 2 , 4 ]","title":"vector_lmul_list_w()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_mask_array_first_masked","text":"Function used to generate mask bits of which the first bit is 0, others are 1 for rvv instruction. Parameters: Name Type Description Default vl int vl register value, which defines mask bits amount in this function. required Returns: Type Description numpy ndarray A numpy ndarray of which the first bit of first element is 0, others are 1, its dtype is numpy.uint8, its size is the integer which is rounded up to after vl is divided by 8. Source code in rvpvp/utils/data.py def vector_mask_array_first_masked ( vl ): '''Function used to generate mask bits of which the first bit is 0, others are 1 for rvv instruction. Args: vl (int): vl register value, which defines mask bits amount in this function. Returns: numpy ndarray: A numpy ndarray of which the first bit of first element is 0, others are 1, its dtype is numpy.uint8, its size is the integer which is rounded up to after vl is divided by 8. ''' mask = np . ones ( vl , dtype = np . uint8 ) mask [ 0 ] = 0 mask = np . packbits ( mask , bitorder = 'little' ) return mask","title":"vector_mask_array_first_masked()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_mask_array_last_masked","text":"Function used to generate mask bits of which the vlth bit is 0, others are 1 for rvv instruction. Parameters: Name Type Description Default vl int vl register value, which defines mask bits amount in this function. required Returns: Type Description numpy ndarray A numpy ndarray of which the vlth bit is 0, others are 1, its dtype is numpy.uint8, its size is the integer which is rounded up to after vl is divided by 8. Source code in rvpvp/utils/data.py def vector_mask_array_last_masked ( vl ): '''Function used to generate mask bits of which the vlth bit is 0, others are 1 for rvv instruction. Args: vl (int): vl register value, which defines mask bits amount in this function. Returns: numpy ndarray: A numpy ndarray of which the vlth bit is 0, others are 1, its dtype is numpy.uint8, its size is the integer which is rounded up to after vl is divided by 8. ''' mask = np . ones ( vl , dtype = np . uint8 ) mask [ vl - 1 ] = 0 mask = np . packbits ( mask , bitorder = 'little' ) return mask","title":"vector_mask_array_last_masked()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_mask_array_random","text":"Function used to generate random mask bits for rvv instructions. Parameters: Name Type Description Default vl int vl register value, which defines mask bits amount in this function. required Returns: Type Description numpy ndarray A random numpy ndarray, its dtype is numpy.uint8, its size is the integer which is rounded up to after vl is divided by 8. The bits above vl are 0. Source code in rvpvp/utils/data.py def vector_mask_array_random ( vl ): '''Function used to generate random mask bits for rvv instructions. Args: vl (int): vl register value, which defines mask bits amount in this function. Returns: numpy ndarray: A random numpy ndarray, its dtype is numpy.uint8, its size is the integer which is rounded up to after vl is divided by 8. The bits above vl are 0. ''' mask = np . array ( np . random . randint ( 0 , 255 , np . ceil ( vl / 8 ) . astype ( np . int16 )), dtype = np . uint8 ) mask = np . unpackbits ( mask , bitorder = 'little' )[ 0 : vl ] mask = np . packbits ( mask , bitorder = 'little' ) return mask","title":"vector_mask_array_random()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_mask_array_zero","text":"Function used to generate zero mask bits for rvv instruction. Parameters: Name Type Description Default vl int vl register value, which defines mask bits amount in this function. required Returns: Type Description numpy ndarray A zero numpy ndarray, its dtype is numpy.uint8, its size is the integer which is rounded up to after vl is divided by 8. Source code in rvpvp/utils/data.py def vector_mask_array_zero ( vl ): '''Function used to generate zero mask bits for rvv instruction. Args: vl (int): vl register value, which defines mask bits amount in this function. Returns: numpy ndarray: A zero numpy ndarray, its dtype is numpy.uint8, its size is the integer which is rounded up to after vl is divided by 8. ''' mask = np . zeros ( int ( np . ceil ( vl / 8 )), dtype = np . uint8 ) return mask","title":"vector_mask_array_zero()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_sew_list_neq_eew","text":"Function to get available vsew values which don't equal to eew. Parameters: Name Type Description Default eew int The present eew value, which can be 8, 16, 32, 64. required Returns: Type Description list A list of available vsew values which don't equal to eew. The available vsew values are 8, 16, 32, 64. Source code in rvpvp/utils/data.py def vector_sew_list_neq_eew ( eew ): '''Function to get available vsew values which don't equal to eew. Args: eew (int): The present eew value, which can be 8, 16, 32, 64. Returns: list: A list of available vsew values which don't equal to eew. The available vsew values are 8, 16, 32, 64. ''' if 8 == eew : return [ 16 , 32 , 64 ] elif 16 == eew : return [ 8 , 32 , 64 ] elif 32 == eew : return [ 8 , 16 , 64 ] elif 64 == eew : return [ 8 , 16 , 32 ]","title":"vector_sew_list_neq_eew()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_stride_list_random","text":"Function to get a list of 5 random int numbers between 0 and 0xff*eew. Parameters: Name Type Description Default eew int effective element width. required Returns: Type Description list A list of 5 random int numbers between 0 and 0xff*eew. Random numbers are generated between 0 and 0xff first, then multiply with eew. Source code in rvpvp/utils/data.py def vector_stride_list_random ( eew ): '''Function to get a list of 5 random int numbers between 0 and 0xff*eew. Args: eew (int): effective element width. Returns: list: A list of 5 random int numbers between 0 and 0xff*eew. Random numbers are generated between 0 and 0xff first, then multiply with eew. ''' return list ( np . random . uniform ( 0 , 0xff , 5 ) . astype ( int ) * eew )","title":"vector_stride_list_random()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_stride_list_random_ls_stride","text":"Function to get a list of random int numbers to be used as stride of vector stride instructions. Parameters: Name Type Description Default vl int vector length register value required eew int effective element length required nf int nf field in vector instruction for segment instructions, default 1. 1 Returns: Type Description list Stride numbers are computed by 0, eew, vl*nf multiplying with eew. If nf > 1, a random int number between 0 and nf and a random int number between nf+1 and 16 multiply with eew and then are appended into the list. Source code in rvpvp/utils/data.py def vector_stride_list_random_ls_stride ( vl , eew , nf = 1 ): '''Function to get a list of random int numbers to be used as stride of vector stride instructions. Args: vl (int): vector length register value eew (int): effective element length nf (int): nf field in vector instruction for segment instructions, default 1. Returns: list: Stride numbers are computed by 0, eew, vl*nf multiplying with eew. If nf > 1, a random int number between 0 and nf and a random int number between nf+1 and 16 multiply with eew and then are appended into the list. ''' stride_list = [ 0 , eew * nf , vl * nf * eew ] if nf > 1 : stride_list . append ( np . random . randint ( 0 , nf ) * eew ) stride_list . append ( np . random . randint ( nf + 1 , 16 ) * eew ) return stride_list","title":"vector_stride_list_random_ls_stride()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_vl_list","text":"Functions to get vl value based on vlen, sew, lmul Parameters: Name Type Description Default lmul int or str vlmul register value required ebits int element bits length, which equals to vsew value. required vlen int rvv register length required Returns: Type Description list A list including 1, vlmax, vlmax-1 and a value between 1 and vlmax-1. If two values are equal, keep one value in the list. Source code in rvpvp/utils/data.py def vector_vl_list ( lmul , ebits , vlen ): '''Functions to get vl value based on vlen, sew, lmul Args: lmul (int or str): vlmul register value ebits (int): element bits length, which equals to vsew value. vlen (int): rvv register length Returns: list: A list including 1, vlmax, vlmax-1 and a value between 1 and vlmax-1. If two values are equal, keep one value in the list. ''' max = int ( vlen * factor_lmul [ lmul ] / ebits ) if 1 < max : if 1 < max - 1 : if 2 < max - 1 : mid = np . random . randint ( 2 , max - 1 ) return [ 1 , mid , max - 1 , max ] else : return [ 1 , max - 1 , max ] else : return [ 1 , max ] else : return [ 1 ]","title":"vector_vl_list()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_vl_list_ls","text":"Function to get vl list for rvv load-store instruction Parameters: Name Type Description Default lmul int or str vlmul register value required sew int vsew register value required eew int effective element width set by load-store instruction required vlen int rvv register length required Returns: Type Description list A list including test vl values for load-store instruction. Source code in rvpvp/utils/data.py def vector_vl_list_ls ( lmul , sew , eew , vlen ): '''Function to get vl list for rvv load-store instruction Args: lmul (int or str): vlmul register value sew (int): vsew register value eew (int): effective element width set by load-store instruction vlen (int): rvv register length Returns: list: A list including test vl values for load-store instruction. ''' emul = sew / eew * factor_lmul [ lmul ] emul = int ( emul if emul >= 1 else 1 ) sum = int ( vlen * factor_lmul [ lmul ] / sew ) esum = int ( vlen * emul / eew ) mid = np . random . randint ( 2 , sum - 1 ) if sum <= esum : return [ 1 , mid , sum - 1 , sum ] else : esum = int ( vlen * factor_lmul [ lmul ] / eew ) vl_list = [ 1 ] for i in range ( 1 , emul + 1 ): isum = int ( vlen * i / eew ) vl_list . append ( isum - 1 ) vl_list . append ( isum ) return vl_list","title":"vector_vl_list_ls()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_vl_list_ls_random","text":"Functions to get random vl list for load&store cases, based on lmul, sew, eew, vlen. Parameters: Name Type Description Default lmul int or str vlmul register value required sew int vsew register value required eew int effective element width required vlen int rvv vector register length required Returns: Type Description list A list including 10 random int numbers between 1 and vlmax Source code in rvpvp/utils/data.py def vector_vl_list_ls_random ( lmul , sew , eew , vlen ): '''Functions to get random vl list for load&store cases, based on lmul, sew, eew, vlen. Args: lmul (int or str): vlmul register value sew (int): vsew register value eew (int): effective element width vlen (int): rvv vector register length Returns: list: A list including 10 random int numbers between 1 and vlmax ''' emul = sew / eew * factor_lmul [ lmul ] emul = int ( emul if emul >= 1 else 1 ) sum = int ( vlen * factor_lmul [ lmul ] / sew ) esum = int ( vlen * emul / eew ) mid = np . random . randint ( 2 , sum - 1 ) minSum = min ( sum , esum ) return list ( np . unique ( np . random . uniform ( 1 , minSum , 10 )) . astype ( int ))","title":"vector_vl_list_ls_random()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_vl_list_ls_seg","text":"Function to get vl list for rvv segment load-store instruction Parameters: Name Type Description Default lmul int or str vlmul register value required sew int vsew register value required eew int effective element width set by load-store instruction required vlen int rvv register length required Returns: Type Description list A list including test vl values for segment load-store instruction. Source code in rvpvp/utils/data.py def vector_vl_list_ls_seg ( lmul , sew , eew , vlen ): '''Function to get vl list for rvv segment load-store instruction Args: lmul (int or str): vlmul register value sew (int): vsew register value eew (int): effective element width set by load-store instruction vlen (int): rvv register length Returns: list: A list including test vl values for segment load-store instruction. ''' emul = sew / eew * factor_lmul [ lmul ] sum = int ( vlen * factor_lmul [ lmul ] / sew ) esum = int ( vlen * emul / eew ) mid = np . random . randint ( 2 , sum - 1 ) if sum <= esum : return [ 1 , mid , sum - 1 , sum ] else : esum = int ( vlen * factor_lmul [ lmul ] / eew ) vl_list = [ 1 ] if emul < 1 : return [ 1 , esum - 1 , esum ] else : for i in range ( 1 , int ( emul + 1 )): isum = int ( vlen * i / eew ) vl_list . append ( isum - 1 ) vl_list . append ( isum ) return vl_list","title":"vector_vl_list_ls_seg()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_vstart_list_linspace","text":"Function to get a list of int numbers to be used as vstart in test cases. Parameters: Name Type Description Default vl int vector length register value required Returns: Type Description list A list of int number between 0 and vl-1. The length of the list is computed by vl//10. Source code in rvpvp/utils/data.py def vector_vstart_list_linspace ( vl ): '''Function to get a list of int numbers to be used as vstart in test cases. Args: vl (int): vector length register value Returns: list: A list of int number between 0 and vl-1. The length of the list is computed by vl//10. ''' return list ( np . unique ( np . linspace ( 0 , vl - 1 , vl // 10 ) . astype ( int )))","title":"vector_vstart_list_linspace()"},{"location":"reference/functions/data/#rvpvp.utils.data.vector_vstart_list_random","text":"Function to get a list of 5 random int numbers between 0 and vl-1 to be used as vstart. Parameters: Name Type Description Default vl int vector length register value required Returns: Type Description list A list of 5 random int number between 0 and vl-1. Source code in rvpvp/utils/data.py def vector_vstart_list_random ( vl ) : '''Function to get a list of 5 random int numbers between 0 and vl-1 to be used as vstart. Args: vl (int): vector length register value Returns: list: A list of 5 random int number between 0 and vl-1. ''' return list ( np . unique ( np . random . uniform ( 0 , vl - 1 , 5 ) . astype ( int )))","title":"vector_vstart_list_random()"},{"location":"reference/functions/utils/","text":"Utility variables and functions alloc_vreg ( lmul , neqs = 'v33' , lmul_neqs = 0 ) Function to get a vector register name, which isn't overlapping with given vector register groups. Parameters: Name Type Description Default lmul int or str vmul register value. required neqs str or list Given vector register or registers, default v33. 'v33' lmul_neqs int,str or list Given lmul corresponding to given vector registers. If it is equal to 0, the function will use the input lmul argument as the given lmul. 0 Returns: Type Description str A vector register name, such as v2. The vector register group won't overlap with the given vector register group. Exceptions: Type Description ValueError If the length of neqs is not equal to the length of lmul_neqs. Source code in rvpvp/utils/utils.py def alloc_vreg ( lmul , neqs = 'v33' , lmul_neqs = 0 ): '''Function to get a vector register name, which isn't overlapping with given vector register groups. Args: lmul (int or str): vmul register value. neqs (str or list): Given vector register or registers, default v33. lmul_neqs (int,str or list ): Given lmul corresponding to given vector registers. If it is equal to 0, the function will use the input lmul argument as the given lmul. Returns: str: A vector register name, such as v2. The vector register group won't overlap with the given vector register group. Raises: ValueError: If the length of neqs is not equal to the length of lmul_neqs. ''' if not isinstance ( neqs , list ): neqs = [ neqs , ] if not isinstance ( lmul_neqs , list ): lmul_neqs = [ lmul_neqs , ] if len ( neqs ) != len ( lmul_neqs ): raise ValueError ( \"The lengths of neqs and lmul_neqs are not equal\" ) return if isinstance ( lmul , str ): lmul = 1 no_neqs = [] for no in range ( len ( lmul_neqs )): if isinstance ( lmul_neqs [ no ], str ): lmul_neqs [ no ] = 1 if 0 == lmul_neqs [ no ]: lmul_neqs [ no ] = lmul no_neqs . append ( int ( neqs [ no ] . replace ( 'v' , '' ) ) ) while True : if isinstance ( lmul , int ) and lmul >= 2 : new_no = factor_lmul [ lmul ] * np . random . randint ( 0 , 32 / factor_lmul [ lmul ]) else : new_no = np . random . randint ( 0 , 32 ) finished = True for i in range ( len ( lmul_neqs )): if ( new_no >= no_neqs [ i ] and new_no < ( no_neqs [ i ] + lmul_neqs [ i ] ) ) or ( no_neqs [ i ] >= new_no and no_neqs [ i ] < ( new_no + lmul ) ): finished = False break if finished : break return 'v' + str ( new_no ) bits_to_bytes ( num ) Function to transfrom bits length to corresponding bytes length. Parameters: Name Type Description Default num int Bits length. required Returns: Type Description int The length of the corresponding bytes of the input bits. Source code in rvpvp/utils/utils.py def bits_to_bytes ( num ): '''Function to transfrom bits length to corresponding bytes length. Args: num (int): Bits length. Returns: int: The length of the corresponding bytes of the input bits. ''' return int ( np . ceil ( num / 8 )) bits_to_dtype_float ( sew ) Function to get float data type corresponding the input width. Parameters: Name Type Description Default sew int vsew register value, float data width, which can be 16, 32, 64. required Returns: Type Description dtype numpy float dtype corresponding to the data width, numpy.float16 corresponding to 16, numpy.float32 corresponding to 32, numpy.float64 corresponding to 64. Source code in rvpvp/utils/utils.py def bits_to_dtype_float ( sew ): '''Function to get float data type corresponding the input width. Args: sew (int): vsew register value, float data width, which can be 16, 32, 64. Returns: dtype: numpy float dtype corresponding to the data width, numpy.float16 corresponding to 16, numpy.float32 corresponding to 32, numpy.float64 corresponding to 64. ''' float_dtype_dict = { 16 : np . float16 , 32 : np . float32 , 64 : np . float64 } return float_dtype_dict [ sew ] bits_to_dtype_int ( sew ) Function to get int data type corresponding the input width. Parameters: Name Type Description Default sew int vsew register value, int data width, which can be 8, 16, 32, 64. required Returns: Type Description dtype numpy int dtype corresponding to the data width, numpy.int8 corresponding to 8, numpy.int16 corresponding to 16, numpy.int32 corresponding to 32, numpy.int64 corresponding to 64. Source code in rvpvp/utils/utils.py def bits_to_dtype_int ( sew ): '''Function to get int data type corresponding the input width. Args: sew (int): vsew register value, int data width, which can be 8, 16, 32, 64. Returns: dtype: numpy int dtype corresponding to the data width, numpy.int8 corresponding to 8, numpy.int16 corresponding to 16, numpy.int32 corresponding to 32, numpy.int64 corresponding to 64. ''' int_dtype_dict = { 8 : np . int8 , 16 : np . int16 , 32 : np . int32 , 64 : np . int64 } return int_dtype_dict [ sew ] bits_to_dtype_uint ( sew ) Function to get uint data type corresponding the input width. Parameters: Name Type Description Default sew int vsew register value, uint data width, which can be 8, 16, 32, 64. required Returns: Type Description dtype numpy uint dtype corresponding to the data width, numpy.uint8 corresponding to 8, numpy.uint16 corresponding to 16, numpy.uint32 corresponding to 32, numpy.uint64 corresponding to 64. Source code in rvpvp/utils/utils.py def bits_to_dtype_uint ( sew ): '''Function to get uint data type corresponding the input width. Args: sew (int): vsew register value, uint data width, which can be 8, 16, 32, 64. Returns: dtype: numpy uint dtype corresponding to the data width, numpy.uint8 corresponding to 8, numpy.uint16 corresponding to 16, numpy.uint32 corresponding to 32, numpy.uint64 corresponding to 64. ''' uint_dtype_dict = { 8 : np . uint8 , 16 : np . uint16 , 32 : np . uint32 , 64 : np . uint64 } return uint_dtype_dict [ sew ] bits_to_intmax ( sew ) Function to get the maximum value in int data type. Parameters: Name Type Description Default sew int data width required Returns: Type Description int The maximum value in int data type of sew width. Source code in rvpvp/utils/utils.py def bits_to_intmax ( sew ): '''Function to get the maximum value in int data type. Args: sew (int): data width Returns: int: The maximum value in int data type of sew width. ''' return 2 ** ( sew - 1 ) - 1 bits_to_intmin ( sew ) Function to get the minimum value in int data type. Parameters: Name Type Description Default sew int data width required Returns: Type Description int The minimum value in int data type of sew width. Source code in rvpvp/utils/utils.py def bits_to_intmin ( sew ): '''Function to get the minimum value in int data type. Args: sew (int): data width Returns: int: The minimum value in int data type of sew width. ''' return - ( 2 ** ( sew - 1 )) bits_to_uintmax ( sew ) Function to get the maximum value in uint data type. Parameters: Name Type Description Default sew int data width required Returns: Type Description int The maximum value in uint data type of sew width. Source code in rvpvp/utils/utils.py def bits_to_uintmax ( sew ): '''Function to get the maximum value in uint data type. Args: sew (int): data width Returns: int: The maximum value in uint data type of sew width. ''' return 2 ** sew - 1 copy_to_dtype ( input , dtype ) Function to copy the input numpy ndarray's dtype to the target dtype, which doesn't change the bytes, just change the bytes interpreting method. Parameters: Name Type Description Default input numpy ndarray The input numpy ndarray need to be transformed. required dtype numpy dtype The target numpy dtype. required Returns: Type Description numpy ndarray The transformed numpy ndarray in the target dtype. Source code in rvpvp/utils/utils.py def copy_to_dtype ( input , dtype ): '''Function to copy the input numpy ndarray's dtype to the target dtype, which doesn't change the bytes, just change the bytes interpreting method. Args: input (numpy ndarray): The input numpy ndarray need to be transformed. dtype (numpy dtype): The target numpy dtype. Returns: numpy ndarray: The transformed numpy ndarray in the target dtype. ''' output = input . copy () if output . shape == (): output = output . reshape ( 1 ,) output . dtype = dtype return output fload_inst ( ebits ) Function to get float load instruction corresponding to the input width. Parameters: Name Type Description Default ebits int float number width required Returns: Type Description str Float load instruction corresponding to the input width. Source code in rvpvp/utils/utils.py def fload_inst ( ebits ): '''Function to get float load instruction corresponding to the input width. Args: ebits (int): float number width Returns: str: Float load instruction corresponding to the input width. ''' return fldins_dict [ ebits ] fstore_inst ( ebits ) Function to get float store instruction corresponding to the input width. Parameters: Name Type Description Default ebits int float number width required Returns: Type Description str Float store instruction corresponding to the input width. Source code in rvpvp/utils/utils.py def fstore_inst ( ebits ): '''Function to get float store instruction corresponding to the input width. Args: ebits (int): float number width Returns: str: Float store instruction corresponding to the input width. ''' return fstins_dict [ ebits ] get_tailmax ( lmul , ebits , vlen = 1024 ) Function to get tail part maximum length in element units of vector operand. Parameters: Name Type Description Default lmul int or str vlmul register value required ebits int element bits length, which equals to vsew value. required vlen int rvv register length 1024 Returns: Type Description int tail part maximum length in element units. When lmul >= 1, it equals to vlmax. When lmul < 1, it equals to vlen/sew. Source code in rvpvp/utils/utils.py def get_tailmax ( lmul , ebits , vlen = 1024 ): '''Function to get tail part maximum length in element units of vector operand. Args: lmul (int or str): vlmul register value ebits (int): element bits length, which equals to vsew value. vlen (int): rvv register length Returns: int: tail part maximum length in element units. When lmul >= 1, it equals to vlmax. When lmul < 1, it equals to vlen/sew. ''' tail = max ( vlen * factor_lmul [ lmul ] // ebits , vlen // ebits ) return tail hex_to_fp16 ( num ) Function to transform a hex uint16 number to corresponding float16 number. Parameters: Name Type Description Default num uint16 The input number need to be transformed. required Returns: Type Description float16 The transformed float16 number from the input number. Source code in rvpvp/utils/utils.py def hex_to_fp16 ( num ): '''Function to transform a hex uint16 number to corresponding float16 number. Args: num (uint16): The input number need to be transformed. Returns: float16: The transformed float16 number from the input number. ''' num = np . array ([ num ], dtype = np . uint16 ) num . dtype = np . float16 return num hex_to_fp32 ( num ) Function to transform a hex uint32 number to corresponding float32 number. Parameters: Name Type Description Default num uint32 The input number need to be transformed. required Returns: Type Description float32 The transformed float32 number from the input number. Source code in rvpvp/utils/utils.py def hex_to_fp32 ( num ): '''Function to transform a hex uint32 number to corresponding float32 number. Args: num (uint32): The input number need to be transformed. Returns: float32: The transformed float32 number from the input number. ''' num = np . array ([ num ], dtype = np . uint32 ) num . dtype = np . float32 return num hex_to_fp64 ( num ) Function to transform a hex uint64 number to corresponding float64 number. Parameters: Name Type Description Default num uint64 The input number need to be transformed. required Returns: Type Description float64 The transformed float64 number from the input number. Source code in rvpvp/utils/utils.py def hex_to_fp64 ( num ): '''Function to transform a hex uint64 number to corresponding float64 number. Args: num (uint64): The input number need to be transformed. Returns: float64: The transformed float64 number from the input number. ''' num = np . array ([ num ], dtype = np . uint64 ) num . dtype = np . float64 return num load_inst ( ebits ) Function to get load instruction corresponding to the input width. Parameters: Name Type Description Default ebits int data width required Returns: Type Description str Float load instruction corresponding to the input width. Source code in rvpvp/utils/utils.py def load_inst ( ebits ): '''Function to get load instruction corresponding to the input width. Args: ebits (int): data width Returns: str: Float load instruction corresponding to the input width. ''' return load_inst_dict [ ebits ] store_inst ( ebits ) Function to get store instruction corresponding to the input width. Parameters: Name Type Description Default ebits int data width required Returns: Type Description str Float store instruction corresponding to the input width. Source code in rvpvp/utils/utils.py def store_inst ( ebits ): '''Function to get store instruction corresponding to the input width. Args: ebits (int): data width Returns: str: Float store instruction corresponding to the input width. ''' return store_inst_dict [ ebits ] vector_emul ( eew , sew , lmul ) Function to get emul based on sew, eew and lmul. Parameters: Name Type Description Default eew int effective element width required sew int selected element width required lmul int or str vlmul register value required Returns: Type Description int or str computed emul value based eew/sew = emul/lmul Source code in rvpvp/utils/utils.py def vector_emul ( eew , sew , lmul ): '''Function to get emul based on sew, eew and lmul. Args: eew (int): effective element width sew (int): selected element width lmul (int or str): vlmul register value Returns: int or str: computed emul value based eew/sew = emul/lmul ''' return string_lmul [ ( eew / sew ) * factor_lmul [ lmul ] ] vector_len_vreg_aligned ( lmul , ebits , vlen ) Function to get maximum element number of the tail part. Parameters: Name Type Description Default lmul int or str vlmul register value required ebits int element bits length, which equals to vsew value. required vlen int rvv register length required Returns: Type Description int The maximum element number of the tail part. When lmul >= 1, the number is computed by vlen*lmul/sew. When lmul < 1, the number is computed by vlen/sew. Source code in rvpvp/utils/utils.py def vector_len_vreg_aligned ( lmul , ebits , vlen ): '''Function to get maximum element number of the tail part. Args: lmul (int or str): vlmul register value ebits (int): element bits length, which equals to vsew value. vlen (int): rvv register length Returns: int: The maximum element number of the tail part. When lmul >= 1, the number is computed by vlen*lmul/sew. When lmul < 1, the number is computed by vlen/sew. ''' if factor_lmul [ lmul ] >= 1 : max = int ( vlen * factor_lmul [ lmul ] / ebits ) else : max = int ( vlen / ebits ) return max vector_vlmax ( lmul , ebits , vlen ) Function to get vlmax based on vlen, sew, lmul. Parameters: Name Type Description Default lmul int or str vlmul register value required ebits int element bits length, which equals to vsew value. required vlen int rvv register length required Returns: Type Description int vlmax value computed based on vlen*lmul/sew Source code in rvpvp/utils/utils.py def vector_vlmax ( lmul , ebits , vlen ): '''Function to get vlmax based on vlen, sew, lmul. Args: lmul (int or str): vlmul register value ebits (int): element bits length, which equals to vsew value. vlen (int): rvv register length Returns: int: vlmax value computed based on vlen*lmul/sew ''' max = int ( vlen * factor_lmul [ lmul ] / ebits ) return max vector_widen_lmul ( lmul ) Function to compute double lmul value of input lmul. Parameters: Name Type Description Default lmul int or str lmul register value, which can be 1, 2, 4, '1', '2', '4', 'f2', 'f4', 'f8' required Returns: Type Description int or str double lmul value Source code in rvpvp/utils/utils.py def vector_widen_lmul ( lmul ): '''Function to compute double lmul value of input lmul. Args: lmul (int or str): lmul register value, which can be 1, 2, 4, '1', '2', '4', 'f2', 'f4', 'f8' Returns: int or str: double lmul value ''' vector_widen_lmul_dict = { 1 : 2 , \"1\" : 2 , 2 : 4 , \"2\" : 4 , 4 : 8 , \"4\" : 8 , 'f2' : 1 , 'f4' : 'f2' , 'f8' : 'f4' } return vector_widen_lmul_dict [ lmul ]","title":"Utilities"},{"location":"reference/functions/utils/#utility-variables-and-functions","text":"","title":"Utility variables and functions"},{"location":"reference/functions/utils/#rvpvp.utils.utils.alloc_vreg","text":"Function to get a vector register name, which isn't overlapping with given vector register groups. Parameters: Name Type Description Default lmul int or str vmul register value. required neqs str or list Given vector register or registers, default v33. 'v33' lmul_neqs int,str or list Given lmul corresponding to given vector registers. If it is equal to 0, the function will use the input lmul argument as the given lmul. 0 Returns: Type Description str A vector register name, such as v2. The vector register group won't overlap with the given vector register group. Exceptions: Type Description ValueError If the length of neqs is not equal to the length of lmul_neqs. Source code in rvpvp/utils/utils.py def alloc_vreg ( lmul , neqs = 'v33' , lmul_neqs = 0 ): '''Function to get a vector register name, which isn't overlapping with given vector register groups. Args: lmul (int or str): vmul register value. neqs (str or list): Given vector register or registers, default v33. lmul_neqs (int,str or list ): Given lmul corresponding to given vector registers. If it is equal to 0, the function will use the input lmul argument as the given lmul. Returns: str: A vector register name, such as v2. The vector register group won't overlap with the given vector register group. Raises: ValueError: If the length of neqs is not equal to the length of lmul_neqs. ''' if not isinstance ( neqs , list ): neqs = [ neqs , ] if not isinstance ( lmul_neqs , list ): lmul_neqs = [ lmul_neqs , ] if len ( neqs ) != len ( lmul_neqs ): raise ValueError ( \"The lengths of neqs and lmul_neqs are not equal\" ) return if isinstance ( lmul , str ): lmul = 1 no_neqs = [] for no in range ( len ( lmul_neqs )): if isinstance ( lmul_neqs [ no ], str ): lmul_neqs [ no ] = 1 if 0 == lmul_neqs [ no ]: lmul_neqs [ no ] = lmul no_neqs . append ( int ( neqs [ no ] . replace ( 'v' , '' ) ) ) while True : if isinstance ( lmul , int ) and lmul >= 2 : new_no = factor_lmul [ lmul ] * np . random . randint ( 0 , 32 / factor_lmul [ lmul ]) else : new_no = np . random . randint ( 0 , 32 ) finished = True for i in range ( len ( lmul_neqs )): if ( new_no >= no_neqs [ i ] and new_no < ( no_neqs [ i ] + lmul_neqs [ i ] ) ) or ( no_neqs [ i ] >= new_no and no_neqs [ i ] < ( new_no + lmul ) ): finished = False break if finished : break return 'v' + str ( new_no )","title":"alloc_vreg()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.bits_to_bytes","text":"Function to transfrom bits length to corresponding bytes length. Parameters: Name Type Description Default num int Bits length. required Returns: Type Description int The length of the corresponding bytes of the input bits. Source code in rvpvp/utils/utils.py def bits_to_bytes ( num ): '''Function to transfrom bits length to corresponding bytes length. Args: num (int): Bits length. Returns: int: The length of the corresponding bytes of the input bits. ''' return int ( np . ceil ( num / 8 ))","title":"bits_to_bytes()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.bits_to_dtype_float","text":"Function to get float data type corresponding the input width. Parameters: Name Type Description Default sew int vsew register value, float data width, which can be 16, 32, 64. required Returns: Type Description dtype numpy float dtype corresponding to the data width, numpy.float16 corresponding to 16, numpy.float32 corresponding to 32, numpy.float64 corresponding to 64. Source code in rvpvp/utils/utils.py def bits_to_dtype_float ( sew ): '''Function to get float data type corresponding the input width. Args: sew (int): vsew register value, float data width, which can be 16, 32, 64. Returns: dtype: numpy float dtype corresponding to the data width, numpy.float16 corresponding to 16, numpy.float32 corresponding to 32, numpy.float64 corresponding to 64. ''' float_dtype_dict = { 16 : np . float16 , 32 : np . float32 , 64 : np . float64 } return float_dtype_dict [ sew ]","title":"bits_to_dtype_float()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.bits_to_dtype_int","text":"Function to get int data type corresponding the input width. Parameters: Name Type Description Default sew int vsew register value, int data width, which can be 8, 16, 32, 64. required Returns: Type Description dtype numpy int dtype corresponding to the data width, numpy.int8 corresponding to 8, numpy.int16 corresponding to 16, numpy.int32 corresponding to 32, numpy.int64 corresponding to 64. Source code in rvpvp/utils/utils.py def bits_to_dtype_int ( sew ): '''Function to get int data type corresponding the input width. Args: sew (int): vsew register value, int data width, which can be 8, 16, 32, 64. Returns: dtype: numpy int dtype corresponding to the data width, numpy.int8 corresponding to 8, numpy.int16 corresponding to 16, numpy.int32 corresponding to 32, numpy.int64 corresponding to 64. ''' int_dtype_dict = { 8 : np . int8 , 16 : np . int16 , 32 : np . int32 , 64 : np . int64 } return int_dtype_dict [ sew ]","title":"bits_to_dtype_int()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.bits_to_dtype_uint","text":"Function to get uint data type corresponding the input width. Parameters: Name Type Description Default sew int vsew register value, uint data width, which can be 8, 16, 32, 64. required Returns: Type Description dtype numpy uint dtype corresponding to the data width, numpy.uint8 corresponding to 8, numpy.uint16 corresponding to 16, numpy.uint32 corresponding to 32, numpy.uint64 corresponding to 64. Source code in rvpvp/utils/utils.py def bits_to_dtype_uint ( sew ): '''Function to get uint data type corresponding the input width. Args: sew (int): vsew register value, uint data width, which can be 8, 16, 32, 64. Returns: dtype: numpy uint dtype corresponding to the data width, numpy.uint8 corresponding to 8, numpy.uint16 corresponding to 16, numpy.uint32 corresponding to 32, numpy.uint64 corresponding to 64. ''' uint_dtype_dict = { 8 : np . uint8 , 16 : np . uint16 , 32 : np . uint32 , 64 : np . uint64 } return uint_dtype_dict [ sew ]","title":"bits_to_dtype_uint()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.bits_to_intmax","text":"Function to get the maximum value in int data type. Parameters: Name Type Description Default sew int data width required Returns: Type Description int The maximum value in int data type of sew width. Source code in rvpvp/utils/utils.py def bits_to_intmax ( sew ): '''Function to get the maximum value in int data type. Args: sew (int): data width Returns: int: The maximum value in int data type of sew width. ''' return 2 ** ( sew - 1 ) - 1","title":"bits_to_intmax()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.bits_to_intmin","text":"Function to get the minimum value in int data type. Parameters: Name Type Description Default sew int data width required Returns: Type Description int The minimum value in int data type of sew width. Source code in rvpvp/utils/utils.py def bits_to_intmin ( sew ): '''Function to get the minimum value in int data type. Args: sew (int): data width Returns: int: The minimum value in int data type of sew width. ''' return - ( 2 ** ( sew - 1 ))","title":"bits_to_intmin()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.bits_to_uintmax","text":"Function to get the maximum value in uint data type. Parameters: Name Type Description Default sew int data width required Returns: Type Description int The maximum value in uint data type of sew width. Source code in rvpvp/utils/utils.py def bits_to_uintmax ( sew ): '''Function to get the maximum value in uint data type. Args: sew (int): data width Returns: int: The maximum value in uint data type of sew width. ''' return 2 ** sew - 1","title":"bits_to_uintmax()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.copy_to_dtype","text":"Function to copy the input numpy ndarray's dtype to the target dtype, which doesn't change the bytes, just change the bytes interpreting method. Parameters: Name Type Description Default input numpy ndarray The input numpy ndarray need to be transformed. required dtype numpy dtype The target numpy dtype. required Returns: Type Description numpy ndarray The transformed numpy ndarray in the target dtype. Source code in rvpvp/utils/utils.py def copy_to_dtype ( input , dtype ): '''Function to copy the input numpy ndarray's dtype to the target dtype, which doesn't change the bytes, just change the bytes interpreting method. Args: input (numpy ndarray): The input numpy ndarray need to be transformed. dtype (numpy dtype): The target numpy dtype. Returns: numpy ndarray: The transformed numpy ndarray in the target dtype. ''' output = input . copy () if output . shape == (): output = output . reshape ( 1 ,) output . dtype = dtype return output","title":"copy_to_dtype()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.fload_inst","text":"Function to get float load instruction corresponding to the input width. Parameters: Name Type Description Default ebits int float number width required Returns: Type Description str Float load instruction corresponding to the input width. Source code in rvpvp/utils/utils.py def fload_inst ( ebits ): '''Function to get float load instruction corresponding to the input width. Args: ebits (int): float number width Returns: str: Float load instruction corresponding to the input width. ''' return fldins_dict [ ebits ]","title":"fload_inst()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.fstore_inst","text":"Function to get float store instruction corresponding to the input width. Parameters: Name Type Description Default ebits int float number width required Returns: Type Description str Float store instruction corresponding to the input width. Source code in rvpvp/utils/utils.py def fstore_inst ( ebits ): '''Function to get float store instruction corresponding to the input width. Args: ebits (int): float number width Returns: str: Float store instruction corresponding to the input width. ''' return fstins_dict [ ebits ]","title":"fstore_inst()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.get_tailmax","text":"Function to get tail part maximum length in element units of vector operand. Parameters: Name Type Description Default lmul int or str vlmul register value required ebits int element bits length, which equals to vsew value. required vlen int rvv register length 1024 Returns: Type Description int tail part maximum length in element units. When lmul >= 1, it equals to vlmax. When lmul < 1, it equals to vlen/sew. Source code in rvpvp/utils/utils.py def get_tailmax ( lmul , ebits , vlen = 1024 ): '''Function to get tail part maximum length in element units of vector operand. Args: lmul (int or str): vlmul register value ebits (int): element bits length, which equals to vsew value. vlen (int): rvv register length Returns: int: tail part maximum length in element units. When lmul >= 1, it equals to vlmax. When lmul < 1, it equals to vlen/sew. ''' tail = max ( vlen * factor_lmul [ lmul ] // ebits , vlen // ebits ) return tail","title":"get_tailmax()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.hex_to_fp16","text":"Function to transform a hex uint16 number to corresponding float16 number. Parameters: Name Type Description Default num uint16 The input number need to be transformed. required Returns: Type Description float16 The transformed float16 number from the input number. Source code in rvpvp/utils/utils.py def hex_to_fp16 ( num ): '''Function to transform a hex uint16 number to corresponding float16 number. Args: num (uint16): The input number need to be transformed. Returns: float16: The transformed float16 number from the input number. ''' num = np . array ([ num ], dtype = np . uint16 ) num . dtype = np . float16 return num","title":"hex_to_fp16()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.hex_to_fp32","text":"Function to transform a hex uint32 number to corresponding float32 number. Parameters: Name Type Description Default num uint32 The input number need to be transformed. required Returns: Type Description float32 The transformed float32 number from the input number. Source code in rvpvp/utils/utils.py def hex_to_fp32 ( num ): '''Function to transform a hex uint32 number to corresponding float32 number. Args: num (uint32): The input number need to be transformed. Returns: float32: The transformed float32 number from the input number. ''' num = np . array ([ num ], dtype = np . uint32 ) num . dtype = np . float32 return num","title":"hex_to_fp32()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.hex_to_fp64","text":"Function to transform a hex uint64 number to corresponding float64 number. Parameters: Name Type Description Default num uint64 The input number need to be transformed. required Returns: Type Description float64 The transformed float64 number from the input number. Source code in rvpvp/utils/utils.py def hex_to_fp64 ( num ): '''Function to transform a hex uint64 number to corresponding float64 number. Args: num (uint64): The input number need to be transformed. Returns: float64: The transformed float64 number from the input number. ''' num = np . array ([ num ], dtype = np . uint64 ) num . dtype = np . float64 return num","title":"hex_to_fp64()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.load_inst","text":"Function to get load instruction corresponding to the input width. Parameters: Name Type Description Default ebits int data width required Returns: Type Description str Float load instruction corresponding to the input width. Source code in rvpvp/utils/utils.py def load_inst ( ebits ): '''Function to get load instruction corresponding to the input width. Args: ebits (int): data width Returns: str: Float load instruction corresponding to the input width. ''' return load_inst_dict [ ebits ]","title":"load_inst()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.store_inst","text":"Function to get store instruction corresponding to the input width. Parameters: Name Type Description Default ebits int data width required Returns: Type Description str Float store instruction corresponding to the input width. Source code in rvpvp/utils/utils.py def store_inst ( ebits ): '''Function to get store instruction corresponding to the input width. Args: ebits (int): data width Returns: str: Float store instruction corresponding to the input width. ''' return store_inst_dict [ ebits ]","title":"store_inst()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.vector_emul","text":"Function to get emul based on sew, eew and lmul. Parameters: Name Type Description Default eew int effective element width required sew int selected element width required lmul int or str vlmul register value required Returns: Type Description int or str computed emul value based eew/sew = emul/lmul Source code in rvpvp/utils/utils.py def vector_emul ( eew , sew , lmul ): '''Function to get emul based on sew, eew and lmul. Args: eew (int): effective element width sew (int): selected element width lmul (int or str): vlmul register value Returns: int or str: computed emul value based eew/sew = emul/lmul ''' return string_lmul [ ( eew / sew ) * factor_lmul [ lmul ] ]","title":"vector_emul()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.vector_len_vreg_aligned","text":"Function to get maximum element number of the tail part. Parameters: Name Type Description Default lmul int or str vlmul register value required ebits int element bits length, which equals to vsew value. required vlen int rvv register length required Returns: Type Description int The maximum element number of the tail part. When lmul >= 1, the number is computed by vlen*lmul/sew. When lmul < 1, the number is computed by vlen/sew. Source code in rvpvp/utils/utils.py def vector_len_vreg_aligned ( lmul , ebits , vlen ): '''Function to get maximum element number of the tail part. Args: lmul (int or str): vlmul register value ebits (int): element bits length, which equals to vsew value. vlen (int): rvv register length Returns: int: The maximum element number of the tail part. When lmul >= 1, the number is computed by vlen*lmul/sew. When lmul < 1, the number is computed by vlen/sew. ''' if factor_lmul [ lmul ] >= 1 : max = int ( vlen * factor_lmul [ lmul ] / ebits ) else : max = int ( vlen / ebits ) return max","title":"vector_len_vreg_aligned()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.vector_vlmax","text":"Function to get vlmax based on vlen, sew, lmul. Parameters: Name Type Description Default lmul int or str vlmul register value required ebits int element bits length, which equals to vsew value. required vlen int rvv register length required Returns: Type Description int vlmax value computed based on vlen*lmul/sew Source code in rvpvp/utils/utils.py def vector_vlmax ( lmul , ebits , vlen ): '''Function to get vlmax based on vlen, sew, lmul. Args: lmul (int or str): vlmul register value ebits (int): element bits length, which equals to vsew value. vlen (int): rvv register length Returns: int: vlmax value computed based on vlen*lmul/sew ''' max = int ( vlen * factor_lmul [ lmul ] / ebits ) return max","title":"vector_vlmax()"},{"location":"reference/functions/utils/#rvpvp.utils.utils.vector_widen_lmul","text":"Function to compute double lmul value of input lmul. Parameters: Name Type Description Default lmul int or str lmul register value, which can be 1, 2, 4, '1', '2', '4', 'f2', 'f4', 'f8' required Returns: Type Description int or str double lmul value Source code in rvpvp/utils/utils.py def vector_widen_lmul ( lmul ): '''Function to compute double lmul value of input lmul. Args: lmul (int or str): lmul register value, which can be 1, 2, 4, '1', '2', '4', 'f2', 'f4', 'f8' Returns: int or str: double lmul value ''' vector_widen_lmul_dict = { 1 : 2 , \"1\" : 2 , 2 : 4 , \"2\" : 4 , 4 : 8 , \"4\" : 8 , 'f2' : 1 , 'f4' : 'f2' , 'f8' : 'f4' } return vector_widen_lmul_dict [ lmul ]","title":"vector_widen_lmul()"}]}